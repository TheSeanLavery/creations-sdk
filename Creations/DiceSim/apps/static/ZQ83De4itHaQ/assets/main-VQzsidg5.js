(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=e(s);fetch(s.href,i)}})();class Xe{constructor(){this.screenWidth=240}setupViewport(){let t=document.querySelector('meta[name="viewport"]');t||(t=document.createElement("meta"),t.name="viewport",document.head.appendChild(t)),t.content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"}}const $e=new Xe;class Ze{constructor(){this.sideButtonEnabled=!0,this.scrollWheelEnabled=!0,this.eventListeners=new Map}init(t={}){this.sideButtonEnabled=t.sideButtonEnabled??!0,this.scrollWheelEnabled=t.scrollWheelEnabled??!0,this.sideButtonEnabled&&this.setupSideButtonListener(),this.scrollWheelEnabled&&this.setupScrollWheelListener(),t.keyboardFallback!==!1&&this.setupKeyboardFallback()}setupSideButtonListener(){window.addEventListener("sideClick",t=>{this.sideButtonEnabled&&this.handleSideButtonClick(t)})}setupScrollWheelListener(){window.addEventListener("scrollUp",t=>{this.scrollWheelEnabled&&this.handleScrollWheel({direction:"up",event:t})}),window.addEventListener("scrollDown",t=>{this.scrollWheelEnabled&&this.handleScrollWheel({direction:"down",event:t})})}setupKeyboardFallback(){window.addEventListener("keydown",t=>{if(t.code==="Space"){t.preventDefault();const e=new CustomEvent("sideClick",{detail:{source:"keyboard"}});window.dispatchEvent(e)}})}handleSideButtonClick(t){(this.eventListeners.get("sideButton")||[]).forEach(n=>n(t))}handleScrollWheel(t){(this.eventListeners.get("scrollWheel")||[]).forEach(n=>n({direction:t.direction,event:t.event}))}on(t,e){this.eventListeners.has(t)||this.eventListeners.set(t,[]),this.eventListeners.get(t).push(e)}off(t,e){const n=this.eventListeners.get(t)||[],s=n.indexOf(e);s>-1&&n.splice(s,1)}}const Me=new Ze;function Ke(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Je(w,t){const e=new Float32Array(16);for(let n=0;n<4;n++){const s=w[n],i=w[n+4],o=w[n+8],r=w[n+12];e[n]=s*t[0]+i*t[1]+o*t[2]+r*t[3],e[n+4]=s*t[4]+i*t[5]+o*t[6]+r*t[7],e[n+8]=s*t[8]+i*t[9]+o*t[10]+r*t[11],e[n+12]=s*t[12]+i*t[13]+o*t[14]+r*t[15]}return e}function Qe(w,t,e,n){const s=1/Math.tan(w/2),i=1/(e-n),o=new Float32Array(16);return o[0]=s/t,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=s,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=(n+e)*i,o[11]=-1,o[12]=0,o[13]=0,o[14]=2*n*e*i,o[15]=0,o}function tn(w,t){const[e,n,s]=t,i=w.slice(0);return i[12]=w[0]*e+w[4]*n+w[8]*s+w[12],i[13]=w[1]*e+w[5]*n+w[9]*s+w[13],i[14]=w[2]*e+w[6]*n+w[10]*s+w[14],i[15]=w[3]*e+w[7]*n+w[11]*s+w[15],i}class tt{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new l);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new l);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new tt);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],c=n[2],a=n[3],d=n[4],u=n[5],h=n[6],f=n[7],p=n[8],y=s[0],m=s[1],x=s[2],v=s[3],g=s[4],b=s[5],z=s[6],C=s[7],_=s[8];return i[0]=o*y+r*v+c*z,i[1]=o*m+r*g+c*C,i[2]=o*x+r*b+c*_,i[3]=a*y+d*v+u*z,i[4]=a*m+d*g+u*C,i[5]=a*x+d*b+u*_,i[6]=h*y+f*v+p*z,i[7]=h*m+f*g+p*C,i[8]=h*x+f*b+p*_,e}scale(t,e){e===void 0&&(e=new tt);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new l);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let c=3;const a=c;let d;const u=4;let h;do{if(o=a-c,i[o+s*o]===0){for(r=o+1;r<a;r++)if(i[o+s*r]!==0){d=u;do h=u-d,i[h+s*o]+=i[h+s*r];while(--d);break}}if(i[o+s*o]!==0)for(r=o+1;r<a;r++){const f=i[o+s*r]/i[o+s*o];d=u;do h=u-d,i[h+s*r]=h<=o?0:i[h+s*r]-i[h+s*o]*f;while(--d)}}while(--c);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new tt);const e=3,n=6,s=en;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const c=r;let a;const d=n;let u;do{if(i=c-r,s[i+n*i]===0){for(o=i+1;o<c;o++)if(s[i+n*o]!==0){a=d;do u=d-a,s[u+n*i]+=s[u+n*o];while(--a);break}}if(s[i+n*i]!==0)for(o=i+1;o<c;o++){const h=s[i+n*o]/s[i+n*i];a=d;do u=d-a,s[u+n*o]=u<=i?0:s[u+n*o]-s[u+n*i]*h;while(--a)}}while(--r);i=2;do{o=i-1;do{const h=s[i+n*o]/s[i+n*i];a=n;do u=n-a,s[u+n*o]=s[u+n*o]-s[u+n*i]*h;while(--a)}while(o--)}while(--i);i=2;do{const h=1/s[i+n*i];a=n;do u=n-a,s[u+n*i]=s[u+n*i]*h;while(--a)}while(i--);i=2;do{o=2;do{if(u=s[e+o+n*i],isNaN(u)||u===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,u)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,c=s+s,a=e*o,d=e*r,u=e*c,h=n*r,f=n*c,p=s*c,y=i*o,m=i*r,x=i*c,v=this.elements;return v[3*0+0]=1-(h+p),v[3*0+1]=d-x,v[3*0+2]=u+m,v[3*1+0]=d+x,v[3*1+1]=1-(a+p),v[3*1+2]=f-y,v[3*2+0]=u-m,v[3*2+1]=f+y,v[3*2+2]=1-(a+h),this}transpose(t){t===void 0&&(t=new tt);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const en=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class l{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new l);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,c=this.z;return e.x=r*i-c*s,e.y=c*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new l(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new l(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new tt([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new l);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new l);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new l),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new l),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new l),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=nn,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=sn;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(se),se.almostEquals(t,e)}clone(){return new l(this.x,this.y,this.z)}}l.ZERO=new l(0,0,0);l.UNIT_X=new l(1,0,0);l.UNIT_Y=new l(0,1,0);l.UNIT_Z=new l(0,0,1);const nn=new l,sn=new l,se=new l;class K{constructor(t){t===void 0&&(t={}),this.lowerBound=new l,this.upperBound=new l,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let c=1;c<t.length;c++){let a=t[c];r&&(r.vmult(a,ie),a=ie),a.x>o.x&&(o.x=a.x),a.x<i.x&&(i.x=a.x),a.y>o.y&&(o.y=a.y),a.y<i.y&&(i.y=a.y),a.z>o.z&&(o.z=a.z),a.z<i.z&&(i.z=a.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new K().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,c=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&c}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,c){const a=this.lowerBound,d=this.upperBound;t.copy(a),e.set(d.x,a.y,a.z),n.set(d.x,d.y,a.z),s.set(a.x,d.y,d.z),i.set(d.x,a.y,d.z),o.set(a.x,d.y,a.z),r.set(a.x,a.y,d.z),c.copy(d)}toLocalFrame(t,e){const n=oe,s=n[0],i=n[1],o=n[2],r=n[3],c=n[4],a=n[5],d=n[6],u=n[7];this.getCorners(s,i,o,r,c,a,d,u);for(let h=0;h!==8;h++){const f=n[h];t.pointToLocal(f,f)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=oe,s=n[0],i=n[1],o=n[2],r=n[3],c=n[4],a=n[5],d=n[6],u=n[7];this.getCorners(s,i,o,r,c,a,d,u);for(let h=0;h!==8;h++){const f=n[h];t.pointToWorld(f,f)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,c=(this.upperBound.x-n.x)*s,a=(this.lowerBound.y-n.y)*i,d=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*o,h=(this.upperBound.z-n.z)*o,f=Math.max(Math.max(Math.min(r,c),Math.min(a,d)),Math.min(u,h)),p=Math.min(Math.min(Math.max(r,c),Math.max(a,d)),Math.max(u,h));return!(p<0||f>p)}}const ie=new l,oe=[new l,new l,new l,new l,new l,new l,new l,new l];class re{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class Be{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class D{constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new l),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=on,s=rn;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new D);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,c=t.y,a=t.z,d=t.w;return e.x=n*d+o*r+s*a-i*c,e.y=s*d+o*c+i*r-n*a,e.z=i*d+o*a+n*c-s*r,e.w=o*d-n*r-s*c-i*a,e}inverse(t){t===void 0&&(t=new D);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new D),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new l);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,c=this.z,a=this.w,d=a*n+r*i-c*s,u=a*s+c*n-o*i,h=a*i+o*s-r*n,f=-o*n-r*s-c*i;return e.x=d*a+f*-o+u*-c-h*-r,e.y=u*a+f*-r+h*-o-d*-c,e.z=h*a+f*-c+d*-r-u*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,c=this.z,a=this.w;switch(e){case"YZX":const d=o*r+c*a;if(d>.499&&(n=2*Math.atan2(o,a),s=Math.PI/2,i=0),d<-.499&&(n=-2*Math.atan2(o,a),s=-Math.PI/2,i=0),n===void 0){const u=o*o,h=r*r,f=c*c;n=Math.atan2(2*r*a-2*o*c,1-2*h-2*f),s=Math.asin(2*d),i=Math.atan2(2*o*a-2*r*c,1-2*u-2*f)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),c=Math.sin(t/2),a=Math.sin(e/2),d=Math.sin(n/2);return s==="XYZ"?(this.x=c*o*r+i*a*d,this.y=i*a*r-c*o*d,this.z=i*o*d+c*a*r,this.w=i*o*r-c*a*d):s==="YXZ"?(this.x=c*o*r+i*a*d,this.y=i*a*r-c*o*d,this.z=i*o*d-c*a*r,this.w=i*o*r+c*a*d):s==="ZXY"?(this.x=c*o*r-i*a*d,this.y=i*a*r+c*o*d,this.z=i*o*d+c*a*r,this.w=i*o*r-c*a*d):s==="ZYX"?(this.x=c*o*r-i*a*d,this.y=i*a*r+c*o*d,this.z=i*o*d-c*a*r,this.w=i*o*r+c*a*d):s==="YZX"?(this.x=c*o*r+i*a*d,this.y=i*a*r+c*o*d,this.z=i*o*d-c*a*r,this.w=i*o*r-c*a*d):s==="XZY"&&(this.x=c*o*r-i*a*d,this.y=i*a*r-c*o*d,this.z=i*o*d+c*a*r,this.w=i*o*r+c*a*d),this}clone(){return new D(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new D);const s=this.x,i=this.y,o=this.z,r=this.w;let c=t.x,a=t.y,d=t.z,u=t.w,h,f,p,y,m;return f=s*c+i*a+o*d+r*u,f<0&&(f=-f,c=-c,a=-a,d=-d,u=-u),1-f>1e-6?(h=Math.acos(f),p=Math.sin(h),y=Math.sin((1-e)*h)/p,m=Math.sin(e*h)/p):(y=1-e,m=e),n.x=y*s+m*c,n.y=y*i+m*a,n.z=y*o+m*d,n.w=y*r+m*u,n}integrate(t,e,n,s){s===void 0&&(s=new D);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,c=this.x,a=this.y,d=this.z,u=this.w,h=e*.5;return s.x+=h*(i*u+o*d-r*a),s.y+=h*(o*u+r*c-i*d),s.z+=h*(r*u+i*a-o*c),s.w+=h*(-i*c-o*a-r*d),s}}const on=new l,rn=new l,cn={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class P{constructor(t){t===void 0&&(t={}),this.id=P.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}P.idCounter=0;P.types=cn;class W{constructor(t){t===void 0&&(t={}),this.position=new l,this.quaternion=new D,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return W.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return W.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new l),n.vsub(t,s),e.conjugate(ce),ce.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new l),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new l),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new l),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const ce=new D;class Bt extends P{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:P.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new l;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let c=0;c!==r;c++){const a=(c+1)%r;e[o[c]].vsub(e[o[a]],s),s.normalize();let d=!1;for(let u=0;u!==n.length;u++)if(n[u].almostEquals(s)||n[u].almostEquals(s)){d=!0;break}d||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new l;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];Bt.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new l,o=new l;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,c,a){const d=new l;let u=-1,h=-Number.MAX_VALUE;for(let p=0;p<n.faces.length;p++){d.copy(n.faceNormals[p]),i.vmult(d,d);const y=d.dot(o);y>h&&(h=y,u=p)}const f=[];for(let p=0;p<n.faces[u].length;p++){const y=n.vertices[n.faces[u][p]],m=new l;m.copy(y),i.vmult(m,m),s.vadd(m,m),f.push(m)}u>=0&&this.clipFaceAgainstHull(o,t,e,f,r,c,a)}findSeparatingAxis(t,e,n,s,i,o,r,c){const a=new l,d=new l,u=new l,h=new l,f=new l,p=new l;let y=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let x=0;x!==m.uniqueAxes.length;x++){n.vmult(m.uniqueAxes[x],a);const v=m.testSepAxis(a,t,e,n,s,i);if(v===!1)return!1;v<y&&(y=v,o.copy(a))}else{const x=r?r.length:m.faces.length;for(let v=0;v<x;v++){const g=r?r[v]:v;a.copy(m.faceNormals[g]),n.vmult(a,a);const b=m.testSepAxis(a,t,e,n,s,i);if(b===!1)return!1;b<y&&(y=b,o.copy(a))}}if(t.uniqueAxes)for(let x=0;x!==t.uniqueAxes.length;x++){i.vmult(t.uniqueAxes[x],d);const v=m.testSepAxis(d,t,e,n,s,i);if(v===!1)return!1;v<y&&(y=v,o.copy(d))}else{const x=c?c.length:t.faces.length;for(let v=0;v<x;v++){const g=c?c[v]:v;d.copy(t.faceNormals[g]),i.vmult(d,d);const b=m.testSepAxis(d,t,e,n,s,i);if(b===!1)return!1;b<y&&(y=b,o.copy(d))}}for(let x=0;x!==m.uniqueEdges.length;x++){n.vmult(m.uniqueEdges[x],h);for(let v=0;v!==t.uniqueEdges.length;v++)if(i.vmult(t.uniqueEdges[v],f),h.cross(f,p),!p.almostZero()){p.normalize();const g=m.testSepAxis(p,t,e,n,s,i);if(g===!1)return!1;g<y&&(y=g,o.copy(p))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;Bt.project(r,t,n,s,Ht),Bt.project(e,t,i,o,Gt);const c=Ht[0],a=Ht[1],d=Gt[0],u=Gt[1];if(c<u||d<a)return!1;const h=c-u,f=d-a;return h<f?h:f}calculateLocalInertia(t,e){const n=new l,s=new l;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const c=new l,a=new l,d=new l,u=new l,h=new l,f=new l,p=new l,y=new l,m=this,x=[],v=s,g=x;let b=-1,z=Number.MAX_VALUE;for(let I=0;I<m.faces.length;I++){c.copy(m.faceNormals[I]),n.vmult(c,c);const R=c.dot(t);R<z&&(z=R,b=I)}if(b<0)return;const C=m.faces[b];C.connectedFaces=[];for(let I=0;I<m.faces.length;I++)for(let R=0;R<m.faces[I].length;R++)C.indexOf(m.faces[I][R])!==-1&&I!==b&&C.connectedFaces.indexOf(I)===-1&&C.connectedFaces.push(I);const _=C.length;for(let I=0;I<_;I++){const R=m.vertices[C[I]],O=m.vertices[C[(I+1)%_]];R.vsub(O,a),d.copy(a),n.vmult(d,d),e.vadd(d,d),u.copy(this.faceNormals[b]),n.vmult(u,u),e.vadd(u,u),d.cross(u,h),h.negate(h),f.copy(R),n.vmult(f,f),e.vadd(f,f);const E=C.connectedFaces[I];p.copy(this.faceNormals[E]);const B=this.getPlaneConstantOfFace(E);y.copy(p),n.vmult(y,y);const M=B-y.dot(e);for(this.clipFaceAgainstPlane(v,g,y,M);v.length;)v.shift();for(;g.length;)v.push(g.shift())}p.copy(this.faceNormals[b]);const N=this.getPlaneConstantOfFace(b);y.copy(p),n.vmult(y,y);const L=N-y.dot(e);for(let I=0;I<v.length;I++){let R=y.dot(v[I])+L;if(R<=i&&(console.log(`clamped: depth=${R} to minDist=${i}`),R=i),R<=o){const O=v[I];if(R<=1e-6){const E={point:O,normal:y,depth:R};r.push(E)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let c=t[t.length-1],a=t[0];i=n.dot(c)+s;for(let d=0;d<r;d++){if(a=t[d],o=n.dot(a)+s,i<0)if(o<0){const u=new l;u.copy(a),e.push(u)}else{const u=new l;c.lerp(a,i/(i-o),u),e.push(u)}else if(o<0){const u=new l;c.lerp(a,i/(i-o),u),e.push(u),e.push(a)}c=a,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new l);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new l);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,c,a,d,u,h=new l;for(let f=0;f<i.length;f++){h.copy(i[f]),e.vmult(h,h),t.vadd(h,h);const p=h;(o===void 0||p.x<o)&&(o=p.x),(a===void 0||p.x>a)&&(a=p.x),(r===void 0||p.y<r)&&(r=p.y),(d===void 0||p.y>d)&&(d=p.y),(c===void 0||p.z<c)&&(c=p.z),(u===void 0||p.z>u)&&(u=p.z)}n.set(o,r,c),s.set(a,d,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new l);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=new l;this.getAveragePointLocal(i);for(let o=0;o<this.faces.length;o++){let r=s[o];const c=e[n[o][0]],a=new l;t.vsub(c,a);const d=r.dot(a),u=new l;i.vsub(c,u);const h=r.dot(u);if(d<0&&h>0||d>0&&h<0)return!1}return-1}static project(t,e,n,s,i){const o=t.vertices.length,r=ln;let c=0,a=0;const d=an,u=t.vertices;d.setZero(),W.vectorToLocalFrame(n,s,e,r),W.pointToLocalFrame(n,s,d,d);const h=d.dot(r);a=c=u[0].dot(r);for(let f=1;f<o;f++){const p=u[f].dot(r);p>c&&(c=p),p<a&&(a=p)}if(a-=h,c-=h,a>c){const f=a;a=c,c=f}i[0]=c,i[1]=a}}const Ht=[],Gt=[];new l;const ln=new l,an=new l;class kt extends P{constructor(t){super({type:P.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=l,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],c=new Bt({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=c,c.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new l),kt.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)dt.set(i[o][0],i[o][1],i[o][2]),e.vmult(dt,dt),t.vadd(dt,dt),n(dt.x,dt.y,dt.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;et[0].set(i.x,i.y,i.z),et[1].set(-i.x,i.y,i.z),et[2].set(-i.x,-i.y,i.z),et[3].set(-i.x,-i.y,-i.z),et[4].set(i.x,-i.y,-i.z),et[5].set(i.x,i.y,-i.z),et[6].set(-i.x,i.y,-i.z),et[7].set(i.x,-i.y,i.z);const o=et[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const c=et[r];e.vmult(c,c),t.vadd(c,c);const a=c.x,d=c.y,u=c.z;a>s.x&&(s.x=a),d>s.y&&(s.y=d),u>s.z&&(s.z=u),a<n.x&&(n.x=a),d<n.y&&(n.y=d),u<n.z&&(n.z=u)}}}const dt=new l,et=[new l,new l,new l,new l,new l,new l,new l,new l],Jt={DYNAMIC:1,STATIC:2,KINEMATIC:4},Qt={AWAKE:0,SLEEPY:1,SLEEPING:2};class F extends Be{constructor(t){t===void 0&&(t={}),super(),this.id=F.idCounter++,this.index=-1,this.world=null,this.vlambda=new l,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new l,this.previousPosition=new l,this.interpolatedPosition=new l,this.initPosition=new l,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new l,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new l,this.force=new l;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=F.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new l,this.quaternion=new D,this.initQuaternion=new D,this.previousQuaternion=new D,this.interpolatedQuaternion=new D,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new l,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new l,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new l,this.invInertia=new l,this.invInertiaWorld=new tt,this.invMassSolve=0,this.invInertiaSolve=new l,this.invInertiaWorldSolve=new tt,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new l(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new l(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new K,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new l,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===F.AWAKE&&n<s?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):e===F.SLEEPY&&n>s?this.wakeUp():e===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new l),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new l),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new l),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new l,i=new D;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),c=o.boundingSphereRadius;r+c>s&&(s=r+c)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=hn,o=dn,r=this.quaternion,c=this.aabb,a=un;for(let d=0;d!==s;d++){const u=t[d];r.vmult(e[d],i),i.vadd(this.position,i),r.mult(n[d],o),u.calculateWorldAABB(i,o,a.lowerBound,a.upperBound),d===0?c.copy(a):c.extend(a)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=pn,s=fn;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new l),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=vn;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new l),this.type!==F.DYNAMIC)return;const n=mn,s=yn;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new l),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=e,s=wn;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=xn;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new l),this.type!==F.DYNAMIC)return;const n=gn,s=bn;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=En;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),kt.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new l;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===F.DYNAMIC||this.type===F.KINEMATIC)||this.sleepState===F.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,c=this.torque,a=this.quaternion,d=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,f=d*t;s.x+=r.x*f*h.x,s.y+=r.y*f*h.y,s.z+=r.z*f*h.z;const p=u.elements,y=this.angularFactor,m=c.x*y.x,x=c.y*y.y,v=c.z*y.z;i.x+=t*(p[0]*m+p[1]*x+p[2]*v),i.y+=t*(p[3]*m+p[4]*x+p[5]*v),i.z+=t*(p[6]*m+p[7]*x+p[8]*v),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,a.integrate(this.angularVelocity,t,this.angularFactor,a),e&&(n?a.normalizeFast():a.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0;F.COLLIDE_EVENT_NAME="collide";F.DYNAMIC=Jt.DYNAMIC;F.STATIC=Jt.STATIC;F.KINEMATIC=Jt.KINEMATIC;F.AWAKE=Qt.AWAKE;F.SLEEPY=Qt.SLEEPY;F.SLEEPING=Qt.SLEEPING;F.wakeupEvent={type:"wakeup"};F.sleepyEvent={type:"sleepy"};F.sleepEvent={type:"sleep"};const hn=new l,dn=new D,un=new K,pn=new tt,fn=new tt;new tt;const vn=new l,mn=new l,yn=new l,wn=new l,xn=new l,gn=new l,bn=new l,En=new l;class _e{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&F.STATIC||t.sleepState===F.SLEEPING)&&(e.type&F.STATIC||e.sleepState===F.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=zn;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=An,s=Sn,i=Cn,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const c=s[r].id,a=i[r].id,d=c<a?`${c},${a}`:`${a},${c}`;n[d]=r,n.keys.push(d)}for(let r=0;r!==n.keys.length;r++){const c=n.keys.pop(),a=n[c];t.push(s[a]),e.push(i[a]),delete n[c]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new l;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const zn=new l;new l;new D;new l;const An={keys:[]},Sn=[],Cn=[];new l;new l;new l;class Mn extends _e{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let c=0;c!==i;c++)for(let a=0;a!==c;a++)o=s[c],r=s[a],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class Vt{constructor(){this.rayFromWorld=new l,this.rayToWorld=new l,this.hitNormalWorld=new l,this.hitPointWorld=new l,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let Pe,Fe,Ie,Ne,Te,Re,Le;const te={CLOSEST:1,ANY:2,ALL:4};Pe=P.types.SPHERE;Fe=P.types.PLANE;Ie=P.types.BOX;Ne=P.types.CYLINDER;Te=P.types.CONVEXPOLYHEDRON;Re=P.types.HEIGHTFIELD;Le=P.types.TRIMESH;class H{get[Pe](){return this._intersectSphere}get[Fe](){return this._intersectPlane}get[Ie](){return this._intersectBox}get[Ne](){return this._intersectConvex}get[Te](){return this._intersectConvex}get[Re](){return this._intersectHeightfield}get[Le](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new l),e===void 0&&(e=new l),this.from=t.clone(),this.to=e.clone(),this.direction=new l,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=H.ANY,this.result=new Vt,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||H.ANY,this.result=e.result||new Vt,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(le),Yt.length=0,t.broadphase.aabbQuery(t,le,Yt),this.intersectBodies(Yt),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=Bn,i=_n;for(let o=0,r=t.shapes.length;o<r;o++){const c=t.shapes[o];if(!(n&&!c.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(c,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(Dn(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,c=this.direction,a=new l(0,0,1);e.vmult(a,a);const d=new l;o.vsub(n,d);const u=d.dot(a);r.vsub(n,d);const h=d.dot(a);if(u*h>0||o.distanceTo(r)<u)return;const f=a.dot(c);if(Math.abs(f)<this.precision)return;const p=new l,y=new l,m=new l;o.vsub(n,p);const x=-a.dot(p)/f;c.scale(x,y),o.vadd(y,m),this.reportIntersection(a,m,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=Pn;o.from.copy(this.from),o.to.copy(this.to),W.pointToLocalFrame(n,e,o.from,o.from),W.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=Fn;let c,a,d,u;c=a=0,d=u=t.data.length-1;const h=new K;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),c=Math.max(c,r[0]),a=Math.max(a,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),d=Math.min(d,r[0]+1),u=Math.min(u,r[1]+1);for(let f=c;f<d;f++)for(let p=a;p<u;p++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(f,p,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(f,p,!1),W.pointToWorldFrame(n,e,t.pillarOffset,Nt),this._intersectConvex(t.pillarConvex,e,Nt,s,i,ae),this.result.shouldStop)return;t.getConvexTrianglePillar(f,p,!0),W.pointToWorldFrame(n,e,t.pillarOffset,Nt),this._intersectConvex(t.pillarConvex,e,Nt,s,i,ae)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,c=t.radius,a=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,d=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),u=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-c**2,h=d**2-4*a*u,f=In,p=Nn;if(!(h<0))if(h===0)o.lerp(r,h,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1);else{const y=(-d-Math.sqrt(h))/(2*a),m=(-d+Math.sqrt(h))/(2*a);if(y>=0&&y<=1&&(o.lerp(r,y,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1)),this.result.shouldStop)return;m>=0&&m<=1&&(o.lerp(r,m,f),f.vsub(n,p),p.normalize(),this.reportIntersection(p,f,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=Tn,c=he,a=o&&o.faceList||null,d=t.faces,u=t.vertices,h=t.faceNormals,f=this.direction,p=this.from,y=this.to,m=p.distanceTo(y),x=a?a.length:d.length,v=this.result;for(let g=0;!v.shouldStop&&g<x;g++){const b=a?a[g]:g,z=d[b],C=h[b],_=e,N=n;c.copy(u[z[0]]),_.vmult(c,c),c.vadd(N,c),c.vsub(p,c),_.vmult(C,r);const L=f.dot(r);if(Math.abs(L)<this.precision)continue;const I=r.dot(c)/L;if(!(I<0)){f.scale(I,$),$.vadd(p,$),Q.copy(u[z[0]]),_.vmult(Q,Q),N.vadd(Q,Q);for(let R=1;!v.shouldStop&&R<z.length-1;R++){nt.copy(u[z[R]]),st.copy(u[z[R+1]]),_.vmult(nt,nt),_.vmult(st,st),N.vadd(nt,nt),N.vadd(st,st);const O=$.distanceTo(p);!(H.pointInTriangle($,Q,nt,st)||H.pointInTriangle($,nt,Q,st))||O>m||this.reportIntersection(r,$,i,s,b)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=Rn,c=kn,a=jn,d=he,u=Ln,h=qn,f=On,p=Wn,y=Vn,m=t.indices;t.vertices;const x=this.from,v=this.to,g=this.direction;a.position.copy(n),a.quaternion.copy(e),W.vectorToLocalFrame(n,e,g,u),W.pointToLocalFrame(n,e,x,h),W.pointToLocalFrame(n,e,v,f),f.x*=t.scale.x,f.y*=t.scale.y,f.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,f.vsub(h,u),u.normalize();const b=h.distanceSquared(f);t.tree.rayQuery(this,a,c);for(let z=0,C=c.length;!this.result.shouldStop&&z!==C;z++){const _=c[z];t.getNormal(_,r),t.getVertex(m[_*3],Q),Q.vsub(h,d);const N=u.dot(r),L=r.dot(d)/N;if(L<0)continue;u.scale(L,$),$.vadd(h,$),t.getVertex(m[_*3+1],nt),t.getVertex(m[_*3+2],st);const I=$.distanceSquared(h);!(H.pointInTriangle($,nt,Q,st)||H.pointInTriangle($,Q,nt,st))||I>b||(W.vectorToWorldFrame(e,r,y),W.pointToWorldFrame(n,e,$,p),this.reportIntersection(y,p,i,s,_))}c.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,c=o.distanceTo(e),a=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(a.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case H.ALL:this.hasHit=!0,a.set(o,r,t,e,n,s,c),a.hasHit=!0,this.callback(a);break;case H.CLOSEST:(c<a.distance||!a.hasHit)&&(this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,n,s,c));break;case H.ANY:this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,n,s,c),a.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,vt),n.vsub(e,At),t.vsub(e,Ut);const i=vt.dot(vt),o=vt.dot(At),r=vt.dot(Ut),c=At.dot(At),a=At.dot(Ut);let d,u;return(d=c*r-o*a)>=0&&(u=i*a-o*r)>=0&&d+u<i*c-o*o}}H.CLOSEST=te.CLOSEST;H.ANY=te.ANY;H.ALL=te.ALL;const le=new K,Yt=[],At=new l,Ut=new l,Bn=new l,_n=new D,$=new l,Q=new l,nt=new l,st=new l;new l;new Vt;const ae={faceList:[0]},Nt=new l,Pn=new H,Fn=[],In=new l,Nn=new l,Tn=new l;new l;new l;const he=new l,Rn=new l,Ln=new l,qn=new l,On=new l,Vn=new l,Wn=new l;new K;const kn=[],jn=new W,vt=new l,Tt=new l;function Dn(w,t,e){e.vsub(w,vt);const n=vt.dot(t);return t.scale(n,Tt),Tt.vadd(w,Tt),e.distanceTo(Tt)}class bt extends _e{static checkBounds(t,e,n){let s,i;n===0?(s=t.position.x,i=e.position.x):n===1?(s=t.position.y,i=e.position.y):n===2&&(s=t.position.z,i=e.position.z);const o=t.boundingRadius,r=e.boundingRadius,c=s+o;return i-r<c}static insertionSortX(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.x<=s.aabb.lowerBound.x);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortY(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.y<=s.aabb.lowerBound.y);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortZ(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.z<=s.aabb.lowerBound.z);i--)t[i+1]=t[i];t[i+1]=s}return t}constructor(t){super(),this.axisList=[],this.world=null,this.axisIndex=0;const e=this.axisList;this._addBodyHandler=n=>{e.push(n.body)},this._removeBodyHandler=n=>{const s=e.indexOf(n.body);s!==-1&&e.splice(s,1)},t&&this.setWorld(t)}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}collisionPairs(t,e,n){const s=this.axisList,i=s.length,o=this.axisIndex;let r,c;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==i;r++){const a=s[r];for(c=r+1;c<i;c++){const d=s[c];if(this.needBroadphaseCollision(a,d)){if(!bt.checkBounds(a,d,o))break;this.intersectionTest(a,d,e,n)}}}}sortList(){const t=this.axisList,e=this.axisIndex,n=t.length;for(let s=0;s!==n;s++){const i=t[s];i.aabbNeedsUpdate&&i.updateAABB()}e===0?bt.insertionSortX(t):e===1?bt.insertionSortY(t):e===2&&bt.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,n=0,s=0,i=0,o=0;const r=this.axisList,c=r.length,a=1/c;for(let f=0;f!==c;f++){const p=r[f],y=p.position.x;t+=y,e+=y*y;const m=p.position.y;n+=m,s+=m*m;const x=p.position.z;i+=x,o+=x*x}const d=e-t*t*a,u=s-n*n*a,h=o-i*i*a;d>u?d>h?this.axisIndex=0:this.axisIndex=2:u>h?this.axisIndex=1:this.axisIndex=2}aabbQuery(t,e,n){n===void 0&&(n=[]),this.dirty&&(this.sortList(),this.dirty=!1);const s=this.axisIndex;let i="x";s===1&&(i="y"),s===2&&(i="z");const o=this.axisList;e.lowerBound[i],e.upperBound[i];for(let r=0;r<o.length;r++){const c=o[r];c.aabbNeedsUpdate&&c.updateAABB(),c.aabb.overlaps(e)&&n.push(c)}return n}}class Hn{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class de{constructor(){this.spatial=new l,this.rotational=new l}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class _t{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=_t.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new de,this.jacobianElementB=new de,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,c=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,c)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,c=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,c)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,c=s.torque,a=n.invMassSolve,d=s.invMassSolve;return i.scale(a,ue),r.scale(d,pe),n.invInertiaWorldSolve.vmult(o,fe),s.invInertiaWorldSolve.vmult(c,ve),t.multiplyVectors(ue,fe)+e.multiplyVectors(pe,ve)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,c=s.invInertiaWorldSolve;let a=i+o;return r.vmult(t.rotational,Rt),a+=Rt.dot(t.rotational),c.vmult(e.rotational,Rt),a+=Rt.dot(e.rotational),a}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=Gn;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}_t.idCounter=0;const ue=new l,pe=new l,fe=new l,ve=new l,Rt=new l,Gn=new l;class Yn extends _t{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new l,this.rj=new l,this.ni=new l}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,c=Un,a=Xn,d=s.velocity,u=s.angularVelocity;s.force,s.torque;const h=i.velocity,f=i.angularVelocity;i.force,i.torque;const p=$n,y=this.jacobianElementA,m=this.jacobianElementB,x=this.ni;o.cross(x,c),r.cross(x,a),x.negate(y.spatial),c.negate(y.rotational),m.spatial.copy(x),m.rotational.copy(a),p.copy(i.position),p.vadd(r,p),p.vsub(s.position,p),p.vsub(o,p);const v=x.dot(p),g=this.restitution+1,b=g*h.dot(x)-g*d.dot(x)+f.dot(a)-u.dot(c),z=this.computeGiMf();return-v*e-b*n-t*z}getImpactVelocityAlongNormal(){const t=Zn,e=Kn,n=Jn,s=Qn,i=ts;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const Un=new l,Xn=new l,$n=new l,Zn=new l,Kn=new l,Jn=new l,Qn=new l,ts=new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;class me extends _t{constructor(t,e,n){super(t,e,-n,n),this.ri=new l,this.rj=new l,this.t=new l}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=es,o=ns,r=this.t;n.cross(r,i),s.cross(r,o);const c=this.jacobianElementA,a=this.jacobianElementB;r.negate(c.spatial),i.negate(c.rotational),a.spatial.copy(r),a.rotational.copy(o);const d=this.computeGW(),u=this.computeGiMf();return-d*e-t*u}}const es=new l,ns=new l;class Pt{constructor(t,e,n){n=Hn.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Pt.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Pt.idCounter=0;class Et{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=Et.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}Et.idCounter=0;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new H;new l;new l;new l;new l(1,0,0),new l(0,1,0),new l(0,0,1);new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;class ss extends P{constructor(){super({type:P.types.PLANE}),this.worldNormal=new l,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){const e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return e===void 0&&(e=new l),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,n,s){rt.set(0,0,1),e.vmult(rt,rt);const i=Number.MAX_VALUE;n.set(-i,-i,-i),s.set(i,i,i),rt.x===1?s.x=t.x:rt.x===-1&&(n.x=t.x),rt.y===1?s.y=t.y:rt.y===-1&&(n.y=t.y),rt.z===1?s.z=t.z:rt.z===-1&&(n.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const rt=new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new l;new K;new l;new K;new l;new l;new l;new l;new l;new l;new l;new K;new l;new W;new K;class is{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class os extends is{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,c=e.bodies,a=c.length,d=t;let u,h,f,p,y,m;if(r!==0)for(let b=0;b!==a;b++)c[b].updateSolveMassProperties();const x=cs,v=ls,g=rs;x.length=r,v.length=r,g.length=r;for(let b=0;b!==r;b++){const z=o[b];g[b]=0,v[b]=z.computeB(d),x[b]=1/z.computeC()}if(r!==0){for(let C=0;C!==a;C++){const _=c[C],N=_.vlambda,L=_.wlambda;N.set(0,0,0),L.set(0,0,0)}for(n=0;n!==s;n++){p=0;for(let C=0;C!==r;C++){const _=o[C];u=v[C],h=x[C],m=g[C],y=_.computeGWlambda(),f=h*(u-y-_.eps*m),m+f<_.minForce?f=_.minForce-m:m+f>_.maxForce&&(f=_.maxForce-m),g[C]+=f,p+=f>0?f:-f,_.addToWlambda(f)}if(p*p<i)break}for(let C=0;C!==a;C++){const _=c[C],N=_.velocity,L=_.angularVelocity;_.vlambda.vmul(_.linearFactor,_.vlambda),N.vadd(_.vlambda,N),_.wlambda.vmul(_.angularFactor,_.wlambda),L.vadd(_.wlambda,L)}let b=o.length;const z=1/d;for(;b--;)o[b].multiplier=g[b]*z}return n}}const rs=[],cs=[],ls=[];class as{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class hs extends as{constructor(){super(...arguments),this.type=l}constructObject(){return new l}}const k={sphereSphere:P.types.SPHERE,spherePlane:P.types.SPHERE|P.types.PLANE,boxBox:P.types.BOX|P.types.BOX,sphereBox:P.types.SPHERE|P.types.BOX,planeBox:P.types.PLANE|P.types.BOX,convexConvex:P.types.CONVEXPOLYHEDRON,sphereConvex:P.types.SPHERE|P.types.CONVEXPOLYHEDRON,planeConvex:P.types.PLANE|P.types.CONVEXPOLYHEDRON,boxConvex:P.types.BOX|P.types.CONVEXPOLYHEDRON,sphereHeightfield:P.types.SPHERE|P.types.HEIGHTFIELD,boxHeightfield:P.types.BOX|P.types.HEIGHTFIELD,convexHeightfield:P.types.CONVEXPOLYHEDRON|P.types.HEIGHTFIELD,sphereParticle:P.types.PARTICLE|P.types.SPHERE,planeParticle:P.types.PLANE|P.types.PARTICLE,boxParticle:P.types.BOX|P.types.PARTICLE,convexParticle:P.types.PARTICLE|P.types.CONVEXPOLYHEDRON,cylinderCylinder:P.types.CYLINDER,sphereCylinder:P.types.SPHERE|P.types.CYLINDER,planeCylinder:P.types.PLANE|P.types.CYLINDER,boxCylinder:P.types.BOX|P.types.CYLINDER,convexCylinder:P.types.CONVEXPOLYHEDRON|P.types.CYLINDER,heightfieldCylinder:P.types.HEIGHTFIELD|P.types.CYLINDER,particleCylinder:P.types.PARTICLE|P.types.CYLINDER,sphereTrimesh:P.types.SPHERE|P.types.TRIMESH,planeTrimesh:P.types.PLANE|P.types.TRIMESH};class ds{get[k.sphereSphere](){return this.sphereSphere}get[k.spherePlane](){return this.spherePlane}get[k.boxBox](){return this.boxBox}get[k.sphereBox](){return this.sphereBox}get[k.planeBox](){return this.planeBox}get[k.convexConvex](){return this.convexConvex}get[k.sphereConvex](){return this.sphereConvex}get[k.planeConvex](){return this.planeConvex}get[k.boxConvex](){return this.boxConvex}get[k.sphereHeightfield](){return this.sphereHeightfield}get[k.boxHeightfield](){return this.boxHeightfield}get[k.convexHeightfield](){return this.convexHeightfield}get[k.sphereParticle](){return this.sphereParticle}get[k.planeParticle](){return this.planeParticle}get[k.boxParticle](){return this.boxParticle}get[k.convexParticle](){return this.convexParticle}get[k.cylinderCylinder](){return this.convexConvex}get[k.sphereCylinder](){return this.sphereConvex}get[k.planeCylinder](){return this.planeConvex}get[k.boxCylinder](){return this.boxConvex}get[k.convexCylinder](){return this.convexConvex}get[k.heightfieldCylinder](){return this.heightfieldCylinder}get[k.particleCylinder](){return this.particleCylinder}get[k.sphereTrimesh](){return this.sphereTrimesh}get[k.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new hs,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new Yn(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const c=this.currentContactMaterial;r.restitution=c.restitution,r.setSpookParams(c.contactEquationStiffness,c.contactEquationRelaxation,this.world.dt);const a=n.material||t.material,d=s.material||e.material;return a&&d&&a.restitution>=0&&d.restitution>=0&&(r.restitution=a.restitution*d.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,c=this.currentContactMaterial;let a=c.friction;const d=i.material||n.material,u=o.material||s.material;if(d&&u&&d.friction>=0&&u.friction>=0&&(a=d.friction*u.friction),a>0){const h=a*(r.frictionGravity||r.gravity).length();let f=n.invMass+s.invMass;f>0&&(f=1/f);const p=this.frictionEquationPool,y=p.length?p.pop():new me(n,s,h*f),m=p.length?p.pop():new me(n,s,h*f);return y.bi=m.bi=n,y.bj=m.bj=s,y.minForce=m.minForce=-h*f,y.maxForce=m.maxForce=h*f,y.ri.copy(t.ri),y.rj.copy(t.rj),m.ri.copy(t.ri),m.rj.copy(t.rj),t.ni.tangents(y.t,m.t),y.setSpookParams(c.frictionEquationStiffness,c.frictionEquationRelaxation,r.dt),m.setSpookParams(c.frictionEquationStiffness,c.frictionEquationRelaxation,r.dt),y.enabled=m.enabled=t.enabled,e.push(y,m),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];ft.setZero(),xt.setZero(),gt.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(ft.vadd(e.ni,ft),xt.vadd(e.ri,xt),gt.vadd(e.rj,gt)):(ft.vsub(e.ni,ft),xt.vadd(e.rj,xt),gt.vadd(e.ri,gt));const o=1/t;xt.scale(o,n.ri),gt.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),ft.normalize(),ft.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const c=fs,a=vs,d=us,u=ps;for(let h=0,f=t.length;h!==f;h++){const p=t[h],y=e[h];let m=null;p.material&&y.material&&(m=n.getContactMaterial(p.material,y.material)||null);const x=p.type&F.KINEMATIC&&y.type&F.STATIC||p.type&F.STATIC&&y.type&F.KINEMATIC||p.type&F.KINEMATIC&&y.type&F.KINEMATIC;for(let v=0;v<p.shapes.length;v++){p.quaternion.mult(p.shapeOrientations[v],c),p.quaternion.vmult(p.shapeOffsets[v],d),d.vadd(p.position,d);const g=p.shapes[v];for(let b=0;b<y.shapes.length;b++){y.quaternion.mult(y.shapeOrientations[b],a),y.quaternion.vmult(y.shapeOffsets[b],u),u.vadd(y.position,u);const z=y.shapes[b];if(!(g.collisionFilterMask&z.collisionFilterGroup&&z.collisionFilterMask&g.collisionFilterGroup)||d.distanceTo(u)>g.boundingSphereRadius+z.boundingSphereRadius)continue;let C=null;g.material&&z.material&&(C=n.getContactMaterial(g.material,z.material)||null),this.currentContactMaterial=C||m||n.defaultContactMaterial;const _=g.type|z.type,N=this[_];if(N){let L=!1;g.type<z.type?L=N.call(this,g,z,d,u,c,a,p,y,g,z,x):L=N.call(this,z,g,u,d,a,c,y,p,g,z,x),L&&x&&(n.shapeOverlapKeeper.set(g.id,z.id),n.bodyOverlapKeeper.set(p.id,y.id))}}}}}sphereSphere(t,e,n,s,i,o,r,c,a,d,u){if(u)return n.distanceSquared(s)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,c,t,e,a,d);s.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(s,h.rj),h.rj.vsub(c.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,c,a,d,u){const h=this.createContactEquation(r,c,t,e,a,d);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),n.vsub(s,Lt),h.ni.scale(h.ni.dot(Lt),ye),Lt.vsub(ye,h.rj),-Lt.dot(h.ni)<=t.radius){if(u)return!0;const f=h.ri,p=h.rj;f.vadd(n,f),f.vsub(r.position,f),p.vadd(s,p),p.vsub(c.position,p),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,c,a,d,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,c,t,e,u)}sphereBox(t,e,n,s,i,o,r,c,a,d,u){const h=this.v3pool,f=ks;n.vsub(s,qt),e.getSideNormals(f,o);const p=t.radius;let y=!1;const m=Ds,x=Hs,v=Gs;let g=null,b=0,z=0,C=0,_=null;for(let A=0,j=f.length;A!==j&&y===!1;A++){const q=Os;q.copy(f[A]);const V=q.length();q.normalize();const X=qt.dot(q);if(X<V+p&&X>0){const Y=Vs,T=Ws;Y.copy(f[(A+1)%3]),T.copy(f[(A+2)%3]);const wt=Y.length(),It=T.length();Y.normalize(),T.normalize();const jt=qt.dot(Y),Dt=qt.dot(T);if(jt<wt&&jt>-wt&&Dt<It&&Dt>-It){const ne=Math.abs(X-V-p);if((_===null||ne<_)&&(_=ne,z=jt,C=Dt,g=V,m.copy(q),x.copy(Y),v.copy(T),b++,u))return!0}}}if(b){y=!0;const A=this.createContactEquation(r,c,t,e,a,d);m.scale(-p,A.ri),A.ni.copy(m),A.ni.negate(A.ni),m.scale(g,m),x.scale(z,x),m.vadd(x,m),v.scale(C,v),m.vadd(v,A.rj),A.ri.vadd(n,A.ri),A.ri.vsub(r.position,A.ri),A.rj.vadd(s,A.rj),A.rj.vsub(c.position,A.rj),this.result.push(A),this.createFrictionEquationsFromContact(A,this.frictionResult)}let N=h.get();const L=js;for(let A=0;A!==2&&!y;A++)for(let j=0;j!==2&&!y;j++)for(let q=0;q!==2&&!y;q++)if(N.set(0,0,0),A?N.vadd(f[0],N):N.vsub(f[0],N),j?N.vadd(f[1],N):N.vsub(f[1],N),q?N.vadd(f[2],N):N.vsub(f[2],N),s.vadd(N,L),L.vsub(n,L),L.lengthSquared()<p*p){if(u)return!0;y=!0;const V=this.createContactEquation(r,c,t,e,a,d);V.ri.copy(L),V.ri.normalize(),V.ni.copy(V.ri),V.ri.scale(p,V.ri),V.rj.copy(N),V.ri.vadd(n,V.ri),V.ri.vsub(r.position,V.ri),V.rj.vadd(s,V.rj),V.rj.vsub(c.position,V.rj),this.result.push(V),this.createFrictionEquationsFromContact(V,this.frictionResult)}h.release(N),N=null;const I=h.get(),R=h.get(),O=h.get(),E=h.get(),B=h.get(),M=f.length;for(let A=0;A!==M&&!y;A++)for(let j=0;j!==M&&!y;j++)if(A%3!==j%3){f[j].cross(f[A],I),I.normalize(),f[A].vadd(f[j],R),O.copy(n),O.vsub(R,O),O.vsub(s,O);const q=O.dot(I);I.scale(q,E);let V=0;for(;V===A%3||V===j%3;)V++;B.copy(n),B.vsub(E,B),B.vsub(R,B),B.vsub(s,B);const X=Math.abs(q),Y=B.length();if(X<f[V].length()&&Y<p){if(u)return!0;y=!0;const T=this.createContactEquation(r,c,t,e,a,d);R.vadd(E,T.rj),T.rj.copy(T.rj),B.negate(T.ni),T.ni.normalize(),T.ri.copy(T.rj),T.ri.vadd(s,T.ri),T.ri.vsub(n,T.ri),T.ri.normalize(),T.ri.scale(p,T.ri),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),T.rj.vadd(s,T.rj),T.rj.vsub(c.position,T.rj),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult)}}h.release(I,R,O,E,B)}planeBox(t,e,n,s,i,o,r,c,a,d,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,c,t,e,u)}convexConvex(t,e,n,s,i,o,r,c,a,d,u,h,f){const p=ri;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,p,h,f)){const y=[],m=ci;t.clipAgainstHull(n,i,e,s,o,p,-100,100,y);let x=0;for(let v=0;v!==y.length;v++){if(u)return!0;const g=this.createContactEquation(r,c,t,e,a,d),b=g.ri,z=g.rj;p.negate(g.ni),y[v].normal.negate(m),m.scale(y[v].depth,m),y[v].point.vadd(m,b),z.copy(y[v].point),b.vsub(n,b),z.vsub(s,z),b.vadd(n,b),b.vsub(r.position,b),z.vadd(s,z),z.vsub(c.position,z),this.result.push(g),x++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(g,this.frictionResult)}this.enableFrictionReduction&&x&&this.createFrictionFromAverage(x)}}sphereConvex(t,e,n,s,i,o,r,c,a,d,u){const h=this.v3pool;n.vsub(s,Ys);const f=e.faceNormals,p=e.faces,y=e.vertices,m=t.radius;let x=!1;for(let v=0;v!==y.length;v++){const g=y[v],b=Zs;o.vmult(g,b),s.vadd(b,b);const z=$s;if(b.vsub(n,z),z.lengthSquared()<m*m){if(u)return!0;x=!0;const C=this.createContactEquation(r,c,t,e,a,d);C.ri.copy(z),C.ri.normalize(),C.ni.copy(C.ri),C.ri.scale(m,C.ri),b.vsub(s,C.rj),C.ri.vadd(n,C.ri),C.ri.vsub(r.position,C.ri),C.rj.vadd(s,C.rj),C.rj.vsub(c.position,C.rj),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult);return}}for(let v=0,g=p.length;v!==g&&x===!1;v++){const b=f[v],z=p[v],C=Ks;o.vmult(b,C);const _=Js;o.vmult(y[z[0]],_),_.vadd(s,_);const N=Qs;C.scale(-m,N),n.vadd(N,N);const L=ti;N.vsub(_,L);const I=L.dot(C),R=ei;if(n.vsub(_,R),I<0&&R.dot(C)>0){const O=[];for(let E=0,B=z.length;E!==B;E++){const M=h.get();o.vmult(y[z[E]],M),s.vadd(M,M),O.push(M)}if(qs(O,C,n)){if(u)return!0;x=!0;const E=this.createContactEquation(r,c,t,e,a,d);C.scale(-m,E.ri),C.negate(E.ni);const B=h.get();C.scale(-I,B);const M=h.get();C.scale(-m,M),n.vsub(s,E.rj),E.rj.vadd(M,E.rj),E.rj.vadd(B,E.rj),E.rj.vadd(s,E.rj),E.rj.vsub(c.position,E.rj),E.ri.vadd(n,E.ri),E.ri.vsub(r.position,E.ri),h.release(B),h.release(M),this.result.push(E),this.createFrictionEquationsFromContact(E,this.frictionResult);for(let A=0,j=O.length;A!==j;A++)h.release(O[A]);return}else for(let E=0;E!==z.length;E++){const B=h.get(),M=h.get();o.vmult(y[z[(E+1)%z.length]],B),o.vmult(y[z[(E+2)%z.length]],M),s.vadd(B,B),s.vadd(M,M);const A=Us;M.vsub(B,A);const j=Xs;A.unit(j);const q=h.get(),V=h.get();n.vsub(B,V);const X=V.dot(j);j.scale(X,q),q.vadd(B,q);const Y=h.get();if(q.vsub(n,Y),X>0&&X*X<A.lengthSquared()&&Y.lengthSquared()<m*m){if(u)return!0;const T=this.createContactEquation(r,c,t,e,a,d);q.vsub(s,T.rj),q.vsub(n,T.ni),T.ni.normalize(),T.ni.scale(m,T.ri),T.rj.vadd(s,T.rj),T.rj.vsub(c.position,T.rj),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult);for(let wt=0,It=O.length;wt!==It;wt++)h.release(O[wt]);h.release(B),h.release(M),h.release(q),h.release(Y),h.release(V);return}h.release(B),h.release(M),h.release(q),h.release(Y),h.release(V)}for(let E=0,B=O.length;E!==B;E++)h.release(O[E])}}}planeConvex(t,e,n,s,i,o,r,c,a,d,u){const h=ni,f=si;f.set(0,0,1),i.vmult(f,f);let p=0;const y=ii;for(let m=0;m!==e.vertices.length;m++)if(h.copy(e.vertices[m]),o.vmult(h,h),s.vadd(h,h),h.vsub(n,y),f.dot(y)<=0){if(u)return!0;const v=this.createContactEquation(r,c,t,e,a,d),g=oi;f.scale(f.dot(y),g),h.vsub(g,g),g.vsub(n,v.ri),v.ni.copy(f),h.vsub(s,v.rj),v.ri.vadd(n,v.ri),v.ri.vsub(r.position,v.ri),v.rj.vadd(s,v.rj),v.rj.vsub(c.position,v.rj),this.result.push(v),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(v,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(t,e,n,s,i,o,r,c,a,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}sphereHeightfield(t,e,n,s,i,o,r,c,a,d,u){const h=e.data,f=t.radius,p=e.elementSize,y=xi,m=wi;W.pointToLocalFrame(s,o,n,m);let x=Math.floor((m.x-f)/p)-1,v=Math.ceil((m.x+f)/p)+1,g=Math.floor((m.y-f)/p)-1,b=Math.ceil((m.y+f)/p)+1;if(v<0||b<0||x>h.length||g>h[0].length)return;x<0&&(x=0),v<0&&(v=0),g<0&&(g=0),b<0&&(b=0),x>=h.length&&(x=h.length-1),v>=h.length&&(v=h.length-1),b>=h[0].length&&(b=h[0].length-1),g>=h[0].length&&(g=h[0].length-1);const z=[];e.getRectMinMax(x,g,v,b,z);const C=z[0],_=z[1];if(m.z-f>_||m.z+f<C)return;const N=this.result;for(let L=x;L<v;L++)for(let I=g;I<b;I++){const R=N.length;let O=!1;if(e.getConvexTrianglePillar(L,I,!1),W.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(O=this.sphereConvex(t,e.pillarConvex,n,y,i,o,r,c,t,e,u)),u&&O||(e.getConvexTrianglePillar(L,I,!0),W.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(O=this.sphereConvex(t,e.pillarConvex,n,y,i,o,r,c,t,e,u)),u&&O))return!0;if(N.length-R>2)return}}boxHeightfield(t,e,n,s,i,o,r,c,a,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}convexHeightfield(t,e,n,s,i,o,r,c,a,d,u){const h=e.data,f=e.elementSize,p=t.boundingSphereRadius,y=mi,m=yi,x=vi;W.pointToLocalFrame(s,o,n,x);let v=Math.floor((x.x-p)/f)-1,g=Math.ceil((x.x+p)/f)+1,b=Math.floor((x.y-p)/f)-1,z=Math.ceil((x.y+p)/f)+1;if(g<0||z<0||v>h.length||b>h[0].length)return;v<0&&(v=0),g<0&&(g=0),b<0&&(b=0),z<0&&(z=0),v>=h.length&&(v=h.length-1),g>=h.length&&(g=h.length-1),z>=h[0].length&&(z=h[0].length-1),b>=h[0].length&&(b=h[0].length-1);const C=[];e.getRectMinMax(v,b,g,z,C);const _=C[0],N=C[1];if(!(x.z-p>N||x.z+p<_))for(let L=v;L<g;L++)for(let I=b;I<z;I++){let R=!1;if(e.getConvexTrianglePillar(L,I,!1),W.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(R=this.convexConvex(t,e.pillarConvex,n,y,i,o,r,c,null,null,u,m,null)),u&&R||(e.getConvexTrianglePillar(L,I,!0),W.pointToWorldFrame(s,o,e.pillarOffset,y),n.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(R=this.convexConvex(t,e.pillarConvex,n,y,i,o,r,c,null,null,u,m,null)),u&&R))return!0}}sphereParticle(t,e,n,s,i,o,r,c,a,d,u){const h=di;if(h.set(0,0,1),s.vsub(n,h),h.lengthSquared()<=t.radius*t.radius){if(u)return!0;const p=this.createContactEquation(c,r,e,t,a,d);h.normalize(),p.rj.copy(h),p.rj.scale(t.radius,p.rj),p.ni.copy(h),p.ni.negate(p.ni),p.ri.set(0,0,0),this.result.push(p),this.createFrictionEquationsFromContact(p,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,c,a,d,u){const h=li;h.set(0,0,1),r.quaternion.vmult(h,h);const f=ai;if(s.vsub(r.position,f),h.dot(f)<=0){if(u)return!0;const y=this.createContactEquation(c,r,e,t,a,d);y.ni.copy(h),y.ni.negate(y.ni),y.ri.set(0,0,0);const m=hi;h.scale(h.dot(s),m),s.vsub(m,m),y.rj.copy(m),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,c,a,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}convexParticle(t,e,n,s,i,o,r,c,a,d,u){let h=-1;const f=pi,p=fi;let y=null;const m=ui;if(m.copy(s),m.vsub(n,m),i.conjugate(we),we.vmult(m,m),t.pointIsInside(m)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let x=0,v=t.faces.length;x!==v;x++){const g=[t.worldVertices[t.faces[x][0]]],b=t.worldFaceNormals[x];s.vsub(g[0],xe);const z=-b.dot(xe);if(y===null||Math.abs(z)<Math.abs(y)){if(u)return!0;y=z,h=x,f.copy(b)}}if(h!==-1){const x=this.createContactEquation(c,r,e,t,a,d);f.scale(y,p),p.vadd(s,p),p.vsub(n,p),x.rj.copy(p),f.negate(x.ni),x.ri.set(0,0,0);const v=x.ri,g=x.rj;v.vadd(s,v),v.vsub(c.position,v),g.vadd(n,g),g.vsub(r.position,g),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,c,a,d,u){return this.convexHeightfield(e,t,s,n,o,i,c,r,a,d,u)}particleCylinder(t,e,n,s,i,o,r,c,a,d,u){return this.convexParticle(e,t,s,n,o,i,c,r,a,d,u)}sphereTrimesh(t,e,n,s,i,o,r,c,a,d,u){const h=zs,f=As,p=Ss,y=Cs,m=Ms,x=Bs,v=Is,g=Es,b=gs,z=Ns;W.pointToLocalFrame(s,o,n,m);const C=t.radius;v.lowerBound.set(m.x-C,m.y-C,m.z-C),v.upperBound.set(m.x+C,m.y+C,m.z+C),e.getTrianglesInAABB(v,z);const _=bs,N=t.radius*t.radius;for(let E=0;E<z.length;E++)for(let B=0;B<3;B++)if(e.getVertex(e.indices[z[E]*3+B],_),_.vsub(m,b),b.lengthSquared()<=N){if(g.copy(_),W.pointToWorldFrame(s,o,g,_),_.vsub(n,b),u)return!0;let M=this.createContactEquation(r,c,t,e,a,d);M.ni.copy(b),M.ni.normalize(),M.ri.copy(M.ni),M.ri.scale(t.radius,M.ri),M.ri.vadd(n,M.ri),M.ri.vsub(r.position,M.ri),M.rj.copy(_),M.rj.vsub(c.position,M.rj),this.result.push(M),this.createFrictionEquationsFromContact(M,this.frictionResult)}for(let E=0;E<z.length;E++)for(let B=0;B<3;B++){e.getVertex(e.indices[z[E]*3+B],h),e.getVertex(e.indices[z[E]*3+(B+1)%3],f),f.vsub(h,p),m.vsub(f,x);const M=x.dot(p);m.vsub(h,x);let A=x.dot(p);if(A>0&&M<0&&(m.vsub(h,x),y.copy(p),y.normalize(),A=x.dot(y),y.scale(A,x),x.vadd(h,x),x.distanceTo(m)<t.radius)){if(u)return!0;const q=this.createContactEquation(r,c,t,e,a,d);x.vsub(m,q.ni),q.ni.normalize(),q.ni.scale(t.radius,q.ri),q.ri.vadd(n,q.ri),q.ri.vsub(r.position,q.ri),W.pointToWorldFrame(s,o,x,x),x.vsub(c.position,q.rj),W.vectorToWorldFrame(o,q.ni,q.ni),W.vectorToWorldFrame(o,q.ri,q.ri),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}}const L=_s,I=Ps,R=Fs,O=xs;for(let E=0,B=z.length;E!==B;E++){e.getTriangleVertices(z[E],L,I,R),e.getNormal(z[E],O),m.vsub(L,x);let M=x.dot(O);if(O.scale(M,x),m.vsub(x,x),M=x.distanceTo(m),H.pointInTriangle(x,L,I,R)&&M<t.radius){if(u)return!0;let A=this.createContactEquation(r,c,t,e,a,d);x.vsub(m,A.ni),A.ni.normalize(),A.ni.scale(t.radius,A.ri),A.ri.vadd(n,A.ri),A.ri.vsub(r.position,A.ri),W.pointToWorldFrame(s,o,x,x),x.vsub(c.position,A.rj),W.vectorToWorldFrame(o,A.ni,A.ni),W.vectorToWorldFrame(o,A.ri,A.ri),this.result.push(A),this.createFrictionEquationsFromContact(A,this.frictionResult)}}z.length=0}planeTrimesh(t,e,n,s,i,o,r,c,a,d,u){const h=new l,f=ms;f.set(0,0,1),i.vmult(f,f);for(let p=0;p<e.vertices.length/3;p++){e.getVertex(p,h);const y=new l;y.copy(h),W.pointToWorldFrame(s,o,y,h);const m=ys;if(h.vsub(n,m),f.dot(m)<=0){if(u)return!0;const v=this.createContactEquation(r,c,t,e,a,d);v.ni.copy(f);const g=ws;f.scale(m.dot(f),g),h.vsub(g,g),v.ri.copy(g),v.ri.vsub(r.position,v.ri),v.rj.copy(h),v.rj.vsub(c.position,v.rj),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}}}}const ft=new l,xt=new l,gt=new l,us=new l,ps=new l,fs=new D,vs=new D,ms=new l,ys=new l,ws=new l,xs=new l,gs=new l;new l;const bs=new l,Es=new l,zs=new l,As=new l,Ss=new l,Cs=new l,Ms=new l,Bs=new l,_s=new l,Ps=new l,Fs=new l,Is=new K,Ns=[],Lt=new l,ye=new l,Ts=new l,Rs=new l,Ls=new l;function qs(w,t,e){let n=null;const s=w.length;for(let i=0;i!==s;i++){const o=w[i],r=Ts;w[(i+1)%s].vsub(o,r);const c=Rs;r.cross(t,c);const a=Ls;e.vsub(o,a);const d=c.dot(a);if(n===null||d>0&&n===!0||d<=0&&n===!1){n===null&&(n=d>0);continue}else return!1}return!0}const qt=new l,Os=new l,Vs=new l,Ws=new l,ks=[new l,new l,new l,new l,new l,new l],js=new l,Ds=new l,Hs=new l,Gs=new l,Ys=new l,Us=new l,Xs=new l,$s=new l,Zs=new l,Ks=new l,Js=new l,Qs=new l,ti=new l,ei=new l;new l;new l;const ni=new l,si=new l,ii=new l,oi=new l,ri=new l,ci=new l,li=new l,ai=new l,hi=new l,di=new l,we=new D,ui=new l;new l;const pi=new l,xe=new l,fi=new l,vi=new l,mi=new l,yi=[0],wi=new l,xi=new l;class ge{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let c=0;c<i;c++){let a=!1;const d=n[c];for(;d>s[r];)r++;a=d===s[r],a||be(t,d)}r=0;for(let c=0;c<o;c++){let a=!1;const d=s[c];for(;d>n[r];)r++;a=n[r]===d,a||be(e,d)}}}function be(w,t){w.push((t&4294901760)>>16,t&65535)}const Xt=(w,t)=>w<t?`${w}-${t}`:`${t}-${w}`;class gi{constructor(){this.data={keys:[]}}get(t,e){const n=Xt(t,e);return this.data[n]}set(t,e,n){const s=Xt(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=Xt(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class bi extends Be{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new l,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new l,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new Mn,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new os,this.constraints=[],this.narrowphase=new ds(this),this.collisionMatrix=new re,this.collisionMatrixPrevious=new re,this.bodyOverlapKeeper=new ge,this.shapeOverlapKeeper=new ge,this.contactmaterials=[],this.contactMaterialTable=new gi,this.defaultMaterial=new Et("default"),this.defaultContactMaterial=new Pt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof Vt?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=H.ALL,n.from=t,n.to=e,n.callback=s,$t.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=H.ANY,n.from=t,n.to=e,n.result=s,$t.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=H.CLOSEST,n.from=t,n.to=e,n.result=s,$t.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=G.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=G.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(G.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const c=this.bodies[r];c.previousPosition.lerp(c.position,o,c.interpolatedPosition),c.previousQuaternion.slerp(c.quaternion,o,c.interpolatedQuaternion),c.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=Ci,s=Mi,i=this.bodies.length,o=this.bodies,r=this.solver,c=this.gravity,a=this.doProfiling,d=this.profile,u=F.DYNAMIC;let h=-1/0;const f=this.constraints,p=Si;c.length();const y=c.x,m=c.y,x=c.z;let v=0;for(a&&(h=G.now()),v=0;v!==i;v++){const E=o[v];if(E.type===u){const B=E.force,M=E.mass;B.x+=M*y,B.y+=M*m,B.z+=M*x}}for(let E=0,B=this.subsystems.length;E!==B;E++)this.subsystems[E].update();a&&(h=G.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),a&&(d.broadphase=G.now()-h);let g=f.length;for(v=0;v!==g;v++){const E=f[v];if(!E.collideConnected)for(let B=n.length-1;B>=0;B-=1)(E.bodyA===n[B]&&E.bodyB===s[B]||E.bodyB===n[B]&&E.bodyA===s[B])&&(n.splice(B,1),s.splice(B,1))}this.collisionMatrixTick(),a&&(h=G.now());const b=Ai,z=e.length;for(v=0;v!==z;v++)b.push(e[v]);e.length=0;const C=this.frictionEquations.length;for(v=0;v!==C;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,b,this.frictionEquations,p),a&&(d.narrowphase=G.now()-h),a&&(h=G.now()),v=0;v<this.frictionEquations.length;v++)r.addEquation(this.frictionEquations[v]);const _=e.length;for(let E=0;E!==_;E++){const B=e[E],M=B.bi,A=B.bj,j=B.si,q=B.sj;let V;if(M.material&&A.material?V=this.getContactMaterial(M.material,A.material)||this.defaultContactMaterial:V=this.defaultContactMaterial,V.friction,M.material&&A.material&&(M.material.friction>=0&&A.material.friction>=0&&M.material.friction*A.material.friction,M.material.restitution>=0&&A.material.restitution>=0&&(B.restitution=M.material.restitution*A.material.restitution)),r.addEquation(B),M.allowSleep&&M.type===F.DYNAMIC&&M.sleepState===F.SLEEPING&&A.sleepState===F.AWAKE&&A.type!==F.STATIC){const X=A.velocity.lengthSquared()+A.angularVelocity.lengthSquared(),Y=A.sleepSpeedLimit**2;X>=Y*2&&(M.wakeUpAfterNarrowphase=!0)}if(A.allowSleep&&A.type===F.DYNAMIC&&A.sleepState===F.SLEEPING&&M.sleepState===F.AWAKE&&M.type!==F.STATIC){const X=M.velocity.lengthSquared()+M.angularVelocity.lengthSquared(),Y=M.sleepSpeedLimit**2;X>=Y*2&&(A.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(M,A,!0),this.collisionMatrixPrevious.get(M,A)||(St.body=A,St.contact=B,M.dispatchEvent(St),St.body=M,A.dispatchEvent(St)),this.bodyOverlapKeeper.set(M.id,A.id),this.shapeOverlapKeeper.set(j.id,q.id)}for(this.emitContactEvents(),a&&(d.makeContactConstraints=G.now()-h,h=G.now()),v=0;v!==i;v++){const E=o[v];E.wakeUpAfterNarrowphase&&(E.wakeUp(),E.wakeUpAfterNarrowphase=!1)}for(g=f.length,v=0;v!==g;v++){const E=f[v];E.update();for(let B=0,M=E.equations.length;B!==M;B++){const A=E.equations[B];r.addEquation(A)}}r.solve(t,this),a&&(d.solve=G.now()-h),r.removeAllEquations();const N=Math.pow;for(v=0;v!==i;v++){const E=o[v];if(E.type&u){const B=N(1-E.linearDamping,t),M=E.velocity;M.scale(B,M);const A=E.angularVelocity;if(A){const j=N(1-E.angularDamping,t);A.scale(j,A)}}}this.dispatchEvent(zi),a&&(h=G.now());const I=this.stepnumber%(this.quatNormalizeSkip+1)===0,R=this.quatNormalizeFast;for(v=0;v!==i;v++)o[v].integrate(t,I,R);this.clearForces(),this.broadphase.dirty=!0,a&&(d.integrate=G.now()-h),this.stepnumber+=1,this.dispatchEvent(Ei);let O=!0;if(this.allowSleep)for(O=!1,v=0;v!==i;v++){const E=o[v];E.sleepTick(this.time),E.sleepState!==F.SLEEPING&&(O=!0)}this.hasActiveBodies=O}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(ct,lt),t){for(let i=0,o=ct.length;i<o;i+=2)Ct.bodyA=this.getBodyById(ct[i]),Ct.bodyB=this.getBodyById(ct[i+1]),this.dispatchEvent(Ct);Ct.bodyA=Ct.bodyB=null}if(e){for(let i=0,o=lt.length;i<o;i+=2)Mt.bodyA=this.getBodyById(lt[i]),Mt.bodyB=this.getBodyById(lt[i+1]),this.dispatchEvent(Mt);Mt.bodyA=Mt.bodyB=null}ct.length=lt.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(ct,lt),n){for(let i=0,o=ct.length;i<o;i+=2){const r=this.getShapeById(ct[i]),c=this.getShapeById(ct[i+1]);at.shapeA=r,at.shapeB=c,r&&(at.bodyA=r.body),c&&(at.bodyB=c.body),this.dispatchEvent(at)}at.bodyA=at.bodyB=at.shapeA=at.shapeB=null}if(s){for(let i=0,o=lt.length;i<o;i+=2){const r=this.getShapeById(lt[i]),c=this.getShapeById(lt[i+1]);ht.shapeA=r,ht.shapeB=c,r&&(ht.bodyA=r.body),c&&(ht.bodyB=c.body),this.dispatchEvent(ht)}ht.bodyA=ht.bodyB=ht.shapeA=ht.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new K;const $t=new H,G=globalThis.performance||{};if(!G.now){let w=Date.now();G.timing&&G.timing.navigationStart&&(w=G.timing.navigationStart),G.now=()=>Date.now()-w}new l;const Ei={type:"postStep"},zi={type:"preStep"},St={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},Ai=[],Si=[],Ci=[],Mi=[],ct=[],lt=[],Ct={type:"beginContact",bodyA:null,bodyB:null},Mt={type:"endContact",bodyA:null,bodyB:null},at={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},ht={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};$e.setupViewport();Me.init({keyboardFallback:!0});const U=document.getElementById("glcanvas"),S=U.getContext("webgl2",{antialias:!0,alpha:!0});S||console.error("WebGL2 not supported");function Bi(w){const t=w[0],e=w[1],n=w[2],s=w[3],i=t+t,o=e+e,r=n+n,c=t*i,a=t*o,d=t*r,u=e*o,h=e*r,f=n*r,p=s*i,y=s*o,m=s*r;return new Float32Array([1-(u+f),a-m,d+y,0,a+m,1-(c+f),h-p,0,d-y,h+p,1-(c+u),0,0,0,0,1])}function _i(){const w=Math.min(window.devicePixelRatio||1,2),t=Math.floor(U.clientWidth*w)||window.innerWidth,e=Math.floor(U.clientHeight*w)||window.innerHeight;(U.width!==t||U.height!==e)&&(U.width=t,U.height=e),S.viewport(0,0,U.width,U.height)}function Pi(){U.style.width||(U.style.width="100vw"),U.style.height||(U.style.height="100vh"),U.style.display="block"}Pi();const Fi=new Float32Array([1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1]),Ii=new Float32Array([1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),qe=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),Ni=`#version 300 es
precision highp float;
layout(location=0) in vec3 a_position;
layout(location=1) in vec3 a_normal;
uniform mat4 u_mvp;
uniform mat4 u_model;
out vec3 v_pos_model;
out vec3 v_nrm_model;
void main(){
  v_pos_model = a_position;
  v_nrm_model = a_normal;
  gl_Position = u_mvp * u_model * vec4(a_position, 1.0);
}`,Ti=`#version 300 es
precision highp float;
in vec3 v_pos_model;
in vec3 v_nrm_model;
out vec4 outColor;

const vec3 LIGHT_DIR = normalize(vec3(0.6, 0.8, 0.4));
const vec3 BASE_COLOR = vec3(0.95);

float sdCircle(vec2 p, float r){ return length(p) - r; }

float addPip(vec2 uv, vec2 c, float r, out vec2 grad){
  vec2 d = uv - c;
  float len = length(d);
  float k = smoothstep(0.25, -0.05, len - r);
  grad = (len > 1e-5) ? (d / len) * k : vec2(0.0);
  return k;
}

void main(){
  vec3 n = normalize(v_nrm_model);
  int faceId = 0; // +X
  vec2 uv;
  // Map model position to face-local uv in [-0.5,0.5]
  if (n.x>0.5) { faceId=0; uv = vec2(v_pos_model.z, -v_pos_model.y) * 0.5; }
  else if (n.x<-0.5) { faceId=1; uv = vec2(v_pos_model.z, v_pos_model.y) * 0.5; }
  else if (n.y>0.5) { faceId=2; uv = vec2(v_pos_model.x, v_pos_model.z) * 0.5; }
  else if (n.y<-0.5) { faceId=3; uv = vec2(v_pos_model.x, -v_pos_model.z) * 0.5; }
  else if (n.z>0.5) { faceId=4; uv = vec2(v_pos_model.x, v_pos_model.y) * 0.5; }
  else { faceId=5; uv = vec2(-v_pos_model.x, v_pos_model.y) * 0.5; }

  // Determine pip layout value for each face
  int val = 1;
  if (faceId==0) val=1;      // +X
  else if (faceId==1) val=6; // -X
  else if (faceId==2) val=2; // +Y
  else if (faceId==3) val=5; // -Y
  else if (faceId==4) val=3; // +Z
  else if (faceId==5) val=4; // -Z

  float r = 0.18; // pip radius in uv units
  float dent = 0.0;
  vec2 gradSum = vec2(0.0);
  vec2 g;

  // Place pips
  if (val==1) {
    dent += addPip(uv, vec2(0.0,0.0), r, g); gradSum += g;
  } else if (val==2) {
    dent += addPip(uv, vec2(-0.5,-0.5), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.5,0.5), r, g); gradSum += g;
  } else if (val==3) {
    dent += addPip(uv, vec2(-0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.0,0.0), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,0.6), r, g); gradSum += g;
  } else if (val==4) {
    dent += addPip(uv, vec2(-0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(-0.6,0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,0.6), r, g); gradSum += g;
  } else if (val==5) {
    dent += addPip(uv, vec2(-0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(-0.6,0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.0,0.0), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,0.6), r, g); gradSum += g;
  } else if (val==6) {
    dent += addPip(uv, vec2(-0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(-0.6,0.0), r, g); gradSum += g;
    dent += addPip(uv, vec2(-0.6,0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,-0.6), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,0.0), r, g); gradSum += g;
    dent += addPip(uv, vec2(0.6,0.6), r, g); gradSum += g;
  }

  // Approximate normal perturbation: bend toward inward (face) and radial gradient
  vec3 planeVec;
  if (faceId==0) planeVec = normalize(vec3(gradSum.y, -gradSum.x, gradSum.x));
  else if (faceId==1) planeVec = normalize(vec3(-gradSum.y, gradSum.x, gradSum.x));
  else if (faceId==2) planeVec = normalize(vec3(gradSum.x, gradSum.y, gradSum.y));
  else if (faceId==3) planeVec = normalize(vec3(gradSum.x, -gradSum.y, -gradSum.y));
  else if (faceId==4) planeVec = normalize(vec3(gradSum.x, gradSum.y, gradSum.x));
  else planeVec = normalize(vec3(-gradSum.x, gradSum.y, -gradSum.x));

  vec3 modN = normalize(n - 0.6 * planeVec - 0.4 * dent * n);
  float ndl = max(0.0, dot(modN, normalize(LIGHT_DIR)));
  vec3 color = BASE_COLOR * (0.25 + 0.75 * ndl);
  color *= mix(1.0, 0.35, clamp(dent * 5.0, 0.0, 1.0));
  outColor = vec4(color, 1.0);
}`,Ri=`#version 300 es
precision highp float;
layout(location=0) in vec3 a_position;
uniform mat4 u_vp;
void main(){ gl_Position = u_vp * vec4(a_position, 1.0); }`,Li=`#version 300 es
precision highp float;
uniform vec4 u_color;
out vec4 outColor;
void main(){ outColor = u_color; }`;function Ee(w,t,e){const n=w.createShader(t);return w.shaderSource(n,e),w.compileShader(n),w.getShaderParameter(n,w.COMPILE_STATUS)?n:(console.error(w.getShaderInfoLog(n)||"shader error"),w.deleteShader(n),null)}function Oe(w,t,e){const n=Ee(w,w.VERTEX_SHADER,t),s=Ee(w,w.FRAGMENT_SHADER,e),i=w.createProgram();return w.attachShader(i,n),w.attachShader(i,s),w.linkProgram(i),w.getProgramParameter(i,w.LINK_STATUS)?i:(console.error(w.getProgramInfoLog(i)||"link error"),w.deleteProgram(i),null)}const ee=Oe(S,Ni,Ti),Ve=S.createVertexArray();S.bindVertexArray(Ve);const qi=S.createBuffer();S.bindBuffer(S.ARRAY_BUFFER,qi);S.bufferData(S.ARRAY_BUFFER,Fi,S.STATIC_DRAW);S.enableVertexAttribArray(0);S.vertexAttribPointer(0,3,S.FLOAT,!1,0,0);const Oi=S.createBuffer();S.bindBuffer(S.ARRAY_BUFFER,Oi);S.bufferData(S.ARRAY_BUFFER,Ii,S.STATIC_DRAW);S.enableVertexAttribArray(1);S.vertexAttribPointer(1,3,S.FLOAT,!1,0,0);const Vi=S.createBuffer();S.bindBuffer(S.ELEMENT_ARRAY_BUFFER,Vi);S.bufferData(S.ELEMENT_ARRAY_BUFFER,qe,S.STATIC_DRAW);const Wi=S.getUniformLocation(ee,"u_mvp"),ki=S.getUniformLocation(ee,"u_model"),Wt=Oe(S,Ri,Li),ze=S.getUniformLocation(Wt,"u_vp"),Ae=S.getUniformLocation(Wt,"u_color");function ji(w){const t=w,e=[],n=[[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t],[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t]],s=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];for(const[i,o]of s)e.push(...n[i],...n[o]);return new Float32Array(e)}const Z=2,We=ji(Z),ke=S.createVertexArray();S.bindVertexArray(ke);const Di=S.createBuffer();S.bindBuffer(S.ARRAY_BUFFER,Di);S.bufferData(S.ARRAY_BUFFER,We,S.STATIC_DRAW);S.enableVertexAttribArray(0);S.vertexAttribPointer(0,3,S.FLOAT,!1,0,0);const je=S.createVertexArray();S.bindVertexArray(je);const Hi=S.createBuffer();S.bindBuffer(S.ARRAY_BUFFER,Hi);const Gi=[[Z,0,0,-1,0,0],[-Z,0,0,1,0,0],[0,Z,0,0,-1,0],[0,-Z,0,0,1,0],[0,0,Z,0,0,-1],[0,0,-Z,0,0,1]],Zt=.6,Kt=[];for(const[w,t,e,n,s,i]of Gi)Kt.push(w,t,e),Kt.push(w+n*Zt,t+s*Zt,e+i*Zt);const De=new Float32Array(Kt);S.bufferData(S.ARRAY_BUFFER,De,S.STATIC_DRAW);S.enableVertexAttribArray(0);S.vertexAttribPointer(0,3,S.FLOAT,!1,0,0);function He(w,t={}){const n=new kt(new l(.5,.5,.5)),s=new F({mass:1,shape:n,material:Ye,angularDamping:.2,linearDamping:.05});if(s.position.set(w[0],w[1],w[2]),t.initialVelocity){const i=t.initialVelocity;s.velocity.set(i[0],i[1],i[2])}else s.velocity.set((Math.random()-.5)*.5,Math.random()*.5,(Math.random()-.5)*.5);if(t.angularVelocity){const i=t.angularVelocity;s.angularVelocity.set(i[0],i[1],i[2])}else s.angularVelocity.set(.5*(Math.random()*2-1),.4*(Math.random()*2-1),.5*(Math.random()*2-1));return s.allowSleep=!0,s.sleepSpeedLimit=.25,s.sleepTimeLimit=.4,J.addBody(s),{size:.5,body:s}}let ot=[],Se=!1,mt=1;function Ot(w,t,e){return Math.max(t,Math.min(e,w))}let ut=0,pt=0;function Yi(){function w(s){const i=(s.beta||0)*Math.PI/180,o=(s.gamma||0)*Math.PI/180;ut=Ot(i,-Math.PI/2,Math.PI/2),pt=Ot(o,-Math.PI/2,Math.PI/2)}try{const s=window.DeviceOrientationEvent;s&&s.requestPermission?document.body.addEventListener("click",async()=>{try{await s.requestPermission()==="granted"&&window.addEventListener("deviceorientation",w)}catch{}},{once:!0}):s&&window.addEventListener("deviceorientation",w)}catch{}let t=!1,e=0,n=0;window.addEventListener("mousedown",s=>{t=!0,e=s.clientX,n=s.clientY}),window.addEventListener("mousemove",s=>{if(!t)return;const i=(s.clientX-e)/window.innerWidth,o=(s.clientY-n)/window.innerHeight;e=s.clientX,n=s.clientY,pt+=i*Math.PI,ut+=o*Math.PI,ut=Ot(ut,-Math.PI/2,Math.PI/2),pt=Ot(pt,-Math.PI/2,Math.PI/2)}),window.addEventListener("mouseup",()=>t=!1)}Yi();let Ft=!1;const yt=new Float32Array([0,-9.8,0]);function Ui(w=60){var t;try{const e=(t=window==null?void 0:window.creationSensors)==null?void 0:t.accelerometer;if(e&&typeof e.start=="function")return e.start(n=>{if(!n)return;const s=typeof n.tiltX=="number"?n.tiltX:typeof n.x=="number"?n.x:0,i=typeof n.tiltY=="number"?n.tiltY:typeof n.y=="number"?n.y:-1,o=typeof n.tiltZ=="number"?n.tiltZ:typeof n.z=="number"?n.z:0,r=9.8*mt;yt[0]=s*r,yt[1]=i*r,yt[2]=o*r,Ft=!0},{frequency:w}),!0}catch{}return!1}function Xi(){var w;try{const t=(w=window==null?void 0:window.creationSensors)==null?void 0:w.accelerometer;if(t&&typeof t.stop=="function")return t.stop(),Ft=!1,!0}catch{}return!1}let it=null;function $i(){const w=document.createElement("div");w.style.position="fixed",w.style.right="8px",w.style.top="8px",w.style.padding="8px 10px",w.style.background="rgba(0,0,0,0.5)",w.style.border="1px solid rgba(255,255,255,0.2)",w.style.borderRadius="6px",w.style.color="#fff",w.style.fontFamily="system-ui, -apple-system, Roboto, sans-serif",w.style.fontSize="12px",w.style.zIndex="1001";const t=document.createElement("div");t.textContent="Tilt",t.style.fontWeight="600",t.style.marginBottom="6px";const e=document.createElement("div");e.innerHTML='x <span id="tilt-x">0.00</span> | y <span id="tilt-y">0.00</span> | z <span id="tilt-z">1.00</span>',e.style.marginBottom="6px";const n=document.createElement("div");n.id="tilt-source",n.textContent="source: fallback",n.style.opacity="0.8",n.style.marginBottom="6px";const s=document.createElement("button");s.id="accel-toggle",s.textContent="Start Accelerometer",s.style.padding="4px 8px",s.style.fontSize="12px",s.style.cursor="pointer",s.style.background="#1b6ef3",s.style.color="#fff",s.style.border="none",s.style.borderRadius="4px",s.addEventListener("click",async()=>{var i;if(Ft)Xi()&&(s.textContent="Start Accelerometer");else{try{const r=(i=window==null?void 0:window.creationSensors)==null?void 0:i.accelerometer;if(!r||typeof r.isAvailable=="function"&&!await r.isAvailable())return}catch{}Ui(60)&&(s.textContent="Stop Accelerometer")}}),w.appendChild(t),w.appendChild(e),w.appendChild(n),w.appendChild(s),document.body.appendChild(w),it={panel:w,vals:e,source:n,btn:s,xEl:w.querySelector("#tilt-x"),yEl:w.querySelector("#tilt-y"),zEl:w.querySelector("#tilt-z")}}$i();function Zi(){if(Ft)return yt;const w=Math.sin(pt),t=-Math.sin(ut),e=-Math.cos(ut)*Math.cos(pt),n=new Float32Array([w,e,t]),s=Math.hypot(n[0],n[1],n[2])||1;return n[0]/=s,n[1]/=s,n[2]/=s,n[0]*=9.8*mt,n[1]*=9.8*mt,n[2]*=9.8*mt,n}S.enable(S.DEPTH_TEST);S.clearColor(.02,.02,.035,1);S.enable(S.BLEND);S.blendFunc(S.SRC_ALPHA,S.ONE_MINUS_SRC_ALPHA);let Ce=performance.now();const J=new bi({gravity:new l(0,-9.8,0)});J.broadphase=new bt(J);J.allowSleep=!0;J.solver.iterations=20;J.defaultContactMaterial.friction=.4;J.defaultContactMaterial.restitution=.25;const Ge=new Et("ground"),Ye=new Et("dice");J.addContactMaterial(new Pt(Ge,Ye,{friction:.6,restitution:.05}));function zt(w,t){const e=new ss,n=new F({mass:0,material:Ge});n.addShape(e);const s=new l(w[0],w[1],w[2]),i=new l(0,0,1),o=new D,r=s.length();r>1e-6&&s.scale(1/r,s);const c=i.dot(s),a=1e-6;if(c>1-a)o.set(0,0,0,1);else if(c<-1+a){const d=Math.abs(i.x)<.9?new l(1,0,0):new l(0,1,0);o.setFromAxisAngle(d,Math.PI)}else{const d=new l;i.cross(s,d);const u=d.length();u>a&&d.scale(1/u,d);const h=Math.acos(Math.max(-1,Math.min(1,c)));o.setFromAxisAngle(d,h)}n.quaternion.copy(o),n.position.set(t[0],t[1],t[2]),J.addBody(n)}zt([-1,0,0],[Z,0,0]);zt([1,0,0],[-Z,0,0]);zt([0,-1,0],[0,Z,0]);zt([0,1,0],[0,-Z,0]);zt([0,0,-1],[0,0,Z]);zt([0,0,1],[0,0,-Z]);function Ki(w){const t=Zi(),e=Math.max(-30,Math.min(30,t[0])),n=Math.max(-30,Math.min(30,t[1])),s=Math.max(-30,Math.min(30,t[2]));J.gravity.set(e,n,s);const i=1/60;J.step(i,w,3)}function Ue(w){_i();const t=Math.min(.033,Math.max(.001,(w-Ce)*.001));Ce=w,Se||(ot.push(He([0,1.2,0],{initialVelocity:[0,0,0],angularVelocity:[0,0,0]})),Se=!0),Ki(t),S.clear(S.COLOR_BUFFER_BIT|S.DEPTH_BUFFER_BIT);const e=U.width/Math.max(1,U.height),n=Qe(Math.PI/3,e,.05,100);let s=Ke();s=tn(s,[0,0,-5]);const i=Je(n,s);it&&(Ft?(it.source.textContent="source: accelerometer",it.xEl.textContent=(yt[0]/(9.8*mt)).toFixed(2),it.yEl.textContent=(yt[1]/(9.8*mt)).toFixed(2),it.zEl.textContent=(yt[2]/(9.8*mt)).toFixed(2)):(it.source.textContent="source: fallback",it.xEl.textContent=Math.sin(pt).toFixed(2),it.yEl.textContent=(-Math.cos(ut)*Math.cos(pt)).toFixed(2),it.zEl.textContent=(-Math.sin(ut)).toFixed(2))),S.useProgram(Wt),S.uniformMatrix4fv(ze,!1,i),S.uniform4f(Ae,1,1,1,.2),S.bindVertexArray(ke),S.drawArrays(S.LINES,0,We.length/3),S.useProgram(Wt),S.uniformMatrix4fv(ze,!1,i),S.uniform4f(Ae,1,1,0,.7),S.bindVertexArray(je),S.drawArrays(S.LINES,0,De.length/3),S.useProgram(ee),S.uniformMatrix4fv(Wi,!1,i),S.bindVertexArray(Ve);for(let o=0;o<ot.length;o++){const r=ot[o],c=r.body,a=new Float32Array([c.quaternion.x,c.quaternion.y,c.quaternion.z,c.quaternion.w]),u=Bi(a).slice(0),h=r.size,f=r.size,p=r.size;u[0]*=h,u[1]*=h,u[2]*=h,u[4]*=f,u[5]*=f,u[6]*=f,u[8]*=p,u[9]*=p,u[10]*=p,u[12]=c.position.x,u[13]=c.position.y,u[14]=c.position.z,S.uniformMatrix4fv(ki,!1,u),S.drawElements(S.TRIANGLES,qe.length,S.UNSIGNED_SHORT,0)}requestAnimationFrame(Ue)}requestAnimationFrame(Ue);Me.on("sideButton",()=>{if(ot.length<8)ot.push(He([(Math.random()-.5)*1.2,1.2+Math.random()*.4,(Math.random()-.5)*1.2]));else{const w=ot.pop();try{J.removeBody(w.body)}catch{}}});try{typeof window<"u"&&(window.__diceDebug={getSpeeds:()=>ot.map(w=>{const t=w.body.velocity;return Math.hypot(t.x,t.y,t.z)}),getAngularSpeeds:()=>ot.map(w=>{const t=w.body.angularVelocity;return Math.hypot(t.x,t.y,t.z)}),getSleeping:()=>ot.map(w=>w.body.sleepState===2),getCount:()=>ot.length})}catch{}
