(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=e(s);fetch(s.href,i)}})();class mn{constructor(){this.screenWidth=240}setupViewport(){let t=document.querySelector('meta[name="viewport"]');t||(t=document.createElement("meta"),t.name="viewport",document.head.appendChild(t)),t.content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"}}const vn=new mn;class yn{constructor(){this.sideButtonEnabled=!0,this.scrollWheelEnabled=!0,this.eventListeners=new Map}init(t={}){this.sideButtonEnabled=t.sideButtonEnabled??!0,this.scrollWheelEnabled=t.scrollWheelEnabled??!0,this.sideButtonEnabled&&this.setupSideButtonListener(),this.scrollWheelEnabled&&this.setupScrollWheelListener(),t.keyboardFallback!==!1&&this.setupKeyboardFallback()}setupSideButtonListener(){window.addEventListener("sideClick",t=>{this.sideButtonEnabled&&this.handleSideButtonClick(t)})}setupScrollWheelListener(){window.addEventListener("scrollUp",t=>{this.scrollWheelEnabled&&this.handleScrollWheel({direction:"up",event:t})}),window.addEventListener("scrollDown",t=>{this.scrollWheelEnabled&&this.handleScrollWheel({direction:"down",event:t})})}setupKeyboardFallback(){window.addEventListener("keydown",t=>{if(t.code==="Space"){t.preventDefault();const e=new CustomEvent("sideClick",{detail:{source:"keyboard"}});window.dispatchEvent(e)}})}handleSideButtonClick(t){(this.eventListeners.get("sideButton")||[]).forEach(n=>n(t))}handleScrollWheel(t){(this.eventListeners.get("scrollWheel")||[]).forEach(n=>n({direction:t.direction,event:t.event}))}on(t,e){this.eventListeners.has(t)||this.eventListeners.set(t,[]),this.eventListeners.get(t).push(e)}off(t,e){const n=this.eventListeners.get(t)||[],s=n.indexOf(e);s>-1&&n.splice(s,1)}}const fe=new yn;function te(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function ze(x,t){const e=new Float32Array(16);for(let n=0;n<4;n++){const s=x[n],i=x[n+4],o=x[n+8],r=x[n+12];e[n]=s*t[0]+i*t[1]+o*t[2]+r*t[3],e[n+4]=s*t[4]+i*t[5]+o*t[6]+r*t[7],e[n+8]=s*t[8]+i*t[9]+o*t[10]+r*t[11],e[n+12]=s*t[12]+i*t[13]+o*t[14]+r*t[15]}return e}function wn(x,t,e,n){const s=1/Math.tan(x/2),i=1/(e-n),o=new Float32Array(16);return o[0]=s/t,o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=s,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=(n+e)*i,o[11]=-1,o[12]=0,o[13]=0,o[14]=2*n*e*i,o[15]=0,o}function xn(x,t){const[e,n,s]=t,i=x.slice(0);return i[12]=x[0]*e+x[4]*n+x[8]*s+x[12],i[13]=x[1]*e+x[5]*n+x[9]*s+x[13],i[14]=x[2]*e+x[6]*n+x[10]*s+x[14],i[15]=x[3]*e+x[7]*n+x[11]*s+x[15],i}class nt{constructor(t){t===void 0&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){t===void 0&&(t=new a);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){e===void 0&&(e=new a);const n=this.elements,s=t.x,i=t.y,o=t.z;return e.x=n[0]*s+n[1]*i+n[2]*o,e.y=n[3]*s+n[4]*i+n[5]*o,e.z=n[6]*s+n[7]*i+n[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){e===void 0&&(e=new nt);const n=this.elements,s=t.elements,i=e.elements,o=n[0],r=n[1],c=n[2],l=n[3],d=n[4],u=n[5],h=n[6],p=n[7],m=n[8],w=s[0],v=s[1],g=s[2],f=s[3],A=s[4],b=s[5],E=s[6],_=s[7],M=s[8];return i[0]=o*w+r*f+c*E,i[1]=o*v+r*A+c*_,i[2]=o*g+r*b+c*M,i[3]=l*w+d*f+u*E,i[4]=l*v+d*A+u*_,i[5]=l*g+d*b+u*M,i[6]=h*w+p*f+m*E,i[7]=h*v+p*A+m*_,i[8]=h*g+p*b+m*M,e}scale(t,e){e===void 0&&(e=new nt);const n=this.elements,s=e.elements;for(let i=0;i!==3;i++)s[3*i+0]=t.x*n[3*i+0],s[3*i+1]=t.y*n[3*i+1],s[3*i+2]=t.z*n[3*i+2];return e}solve(t,e){e===void 0&&(e=new a);const n=3,s=4,i=[];let o,r;for(o=0;o<n*s;o++)i.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)i[o+s*r]=this.elements[o+3*r];i[3+4*0]=t.x,i[3+4*1]=t.y,i[3+4*2]=t.z;let c=3;const l=c;let d;const u=4;let h;do{if(o=l-c,i[o+s*o]===0){for(r=o+1;r<l;r++)if(i[o+s*r]!==0){d=u;do h=u-d,i[h+s*o]+=i[h+s*r];while(--d);break}}if(i[o+s*o]!==0)for(r=o+1;r<l;r++){const p=i[o+s*r]/i[o+s*o];d=u;do h=u-d,i[h+s*r]=h<=o?0:i[h+s*r]-i[h+s*o]*p;while(--d)}}while(--c);if(e.z=i[2*s+3]/i[2*s+2],e.y=(i[1*s+3]-i[1*s+2]*e.z)/i[1*s+1],e.x=(i[0*s+3]-i[0*s+2]*e.z-i[0*s+1]*e.y)/i[0*s+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,n){if(n===void 0)return this.elements[e+3*t];this.elements[e+3*t]=n}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let n=0;n<9;n++)t+=this.elements[n]+e;return t}reverse(t){t===void 0&&(t=new nt);const e=3,n=6,s=gn;let i,o;for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+n*o]=this.elements[i+3*o];s[3+6*0]=1,s[3+6*1]=0,s[3+6*2]=0,s[4+6*0]=0,s[4+6*1]=1,s[4+6*2]=0,s[5+6*0]=0,s[5+6*1]=0,s[5+6*2]=1;let r=3;const c=r;let l;const d=n;let u;do{if(i=c-r,s[i+n*i]===0){for(o=i+1;o<c;o++)if(s[i+n*o]!==0){l=d;do u=d-l,s[u+n*i]+=s[u+n*o];while(--l);break}}if(s[i+n*i]!==0)for(o=i+1;o<c;o++){const h=s[i+n*o]/s[i+n*i];l=d;do u=d-l,s[u+n*o]=u<=i?0:s[u+n*o]-s[u+n*i]*h;while(--l)}}while(--r);i=2;do{o=i-1;do{const h=s[i+n*o]/s[i+n*i];l=n;do u=n-l,s[u+n*o]=s[u+n*o]-s[u+n*i]*h;while(--l)}while(o--)}while(--i);i=2;do{const h=1/s[i+n*i];l=n;do u=n-l,s[u+n*i]=s[u+n*i]*h;while(--l)}while(i--);i=2;do{o=2;do{if(u=s[e+o+n*i],isNaN(u)||u===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(i,o,u)}while(o--)}while(i--);return t}setRotationFromQuaternion(t){const e=t.x,n=t.y,s=t.z,i=t.w,o=e+e,r=n+n,c=s+s,l=e*o,d=e*r,u=e*c,h=n*r,p=n*c,m=s*c,w=i*o,v=i*r,g=i*c,f=this.elements;return f[3*0+0]=1-(h+m),f[3*0+1]=d-g,f[3*0+2]=u+v,f[3*1+0]=d+g,f[3*1+1]=1-(l+m),f[3*1+2]=p-w,f[3*2+0]=u-v,f[3*2+1]=p+w,f[3*2+2]=1-(l+h),this}transpose(t){t===void 0&&(t=new nt);const e=this.elements,n=t.elements;let s;return n[0]=e[0],n[4]=e[4],n[8]=e[8],s=e[1],n[1]=e[3],n[3]=s,s=e[2],n[2]=e[6],n[6]=s,s=e[5],n[5]=e[7],n[7]=s,t}}const gn=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class a{constructor(t,e,n){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),this.x=t,this.y=e,this.z=n}cross(t,e){e===void 0&&(e=new a);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,c=this.z;return e.x=r*i-c*s,e.y=c*n-o*i,e.z=o*s-r*n,e}set(t,e,n){return this.x=t,this.y=e,this.z=n,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new a(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new a(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new nt([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,n=this.z,s=Math.sqrt(t*t+e*e+n*n);if(s>0){const i=1/s;this.x*=i,this.y*=i,this.z*=i}else this.x=0,this.y=0,this.z=0;return s}unit(t){t===void 0&&(t=new a);const e=this.x,n=this.y,s=this.z;let i=Math.sqrt(e*e+n*n+s*s);return i>0?(i=1/i,t.x=e*i,t.y=n*i,t.z=s*i):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,n=this.z;return Math.sqrt(t*t+e*e+n*n)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return Math.sqrt((i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s))}distanceSquared(t){const e=this.x,n=this.y,s=this.z,i=t.x,o=t.y,r=t.z;return(i-e)*(i-e)+(o-n)*(o-n)+(r-s)*(r-s)}scale(t,e){e===void 0&&(e=new a);const n=this.x,s=this.y,i=this.z;return e.x=t*n,e.y=t*s,e.z=t*i,e}vmul(t,e){return e===void 0&&(e=new a),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,n){return n===void 0&&(n=new a),n.x=this.x+t*e.x,n.y=this.y+t*e.y,n.z=this.z+t*e.z,n}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t){return t===void 0&&(t=new a),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const n=this.length();if(n>0){const s=bn,i=1/n;s.set(this.x*i,this.y*i,this.z*i);const o=En;Math.abs(s.x)<.9?(o.set(1,0,0),s.cross(o,t)):(o.set(0,1,0),s.cross(o,t)),s.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,n){const s=this.x,i=this.y,o=this.z;n.x=s+(t.x-s)*e,n.y=i+(t.y-i)*e,n.z=o+(t.z-o)*e}almostEquals(t,e){return e===void 0&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return t===void 0&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(Ce),Ce.almostEquals(t,e)}clone(){return new a(this.x,this.y,this.z)}}a.ZERO=new a(0,0,0);a.UNIT_X=new a(1,0,0);a.UNIT_Y=new a(0,1,0);a.UNIT_Z=new a(0,0,1);const bn=new a,En=new a,Ce=new a;class tt{constructor(t){t===void 0&&(t={}),this.lowerBound=new a,this.upperBound=new a,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,n,s){const i=this.lowerBound,o=this.upperBound,r=n;i.copy(t[0]),r&&r.vmult(i,i),o.copy(i);for(let c=1;c<t.length;c++){let l=t[c];r&&(r.vmult(l,_e),l=_e),l.x>o.x&&(o.x=l.x),l.x<i.x&&(i.x=l.x),l.y>o.y&&(o.y=l.y),l.y<i.y&&(i.y=l.y),l.z>o.z&&(o.z=l.z),l.z<i.z&&(i.z=l.z)}return e&&(e.vadd(i,i),e.vadd(o,o)),s&&(i.x-=s,i.y-=s,i.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new tt().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound,o=s.x<=n.x&&n.x<=i.x||e.x<=i.x&&i.x<=n.x,r=s.y<=n.y&&n.y<=i.y||e.y<=i.y&&i.y<=n.y,c=s.z<=n.z&&n.z<=i.z||e.z<=i.z&&i.z<=n.z;return o&&r&&c}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,n=this.upperBound,s=t.lowerBound,i=t.upperBound;return e.x<=s.x&&n.x>=i.x&&e.y<=s.y&&n.y>=i.y&&e.z<=s.z&&n.z>=i.z}getCorners(t,e,n,s,i,o,r,c){const l=this.lowerBound,d=this.upperBound;t.copy(l),e.set(d.x,l.y,l.z),n.set(d.x,d.y,l.z),s.set(l.x,d.y,d.z),i.set(d.x,l.y,d.z),o.set(l.x,d.y,l.z),r.set(l.x,l.y,d.z),c.copy(d)}toLocalFrame(t,e){const n=Me,s=n[0],i=n[1],o=n[2],r=n[3],c=n[4],l=n[5],d=n[6],u=n[7];this.getCorners(s,i,o,r,c,l,d,u);for(let h=0;h!==8;h++){const p=n[h];t.pointToLocal(p,p)}return e.setFromPoints(n)}toWorldFrame(t,e){const n=Me,s=n[0],i=n[1],o=n[2],r=n[3],c=n[4],l=n[5],d=n[6],u=n[7];this.getCorners(s,i,o,r,c,l,d,u);for(let h=0;h!==8;h++){const p=n[h];t.pointToWorld(p,p)}return e.setFromPoints(n)}overlapsRay(t){const{direction:e,from:n}=t,s=1/e.x,i=1/e.y,o=1/e.z,r=(this.lowerBound.x-n.x)*s,c=(this.upperBound.x-n.x)*s,l=(this.lowerBound.y-n.y)*i,d=(this.upperBound.y-n.y)*i,u=(this.lowerBound.z-n.z)*o,h=(this.upperBound.z-n.z)*o,p=Math.max(Math.max(Math.min(r,c),Math.min(l,d)),Math.min(u,h)),m=Math.min(Math.min(Math.max(r,c),Math.max(l,d)),Math.max(u,h));return!(m<0||p>m)}}const _e=new a,Me=[new a,new a,new a,new a,new a,new a,new a,new a];class Te{constructor(){this.matrix=[]}get(t,e){let{index:n}=t,{index:s}=e;if(s>n){const i=s;s=n,n=i}return this.matrix[(n*(n+1)>>1)+s-1]}set(t,e,n){let{index:s}=t,{index:i}=e;if(i>s){const o=i;i=s,s=o}this.matrix[(s*(s+1)>>1)+i-1]=n?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class Qe{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;return n[t]===void 0&&(n[t]=[]),n[t].includes(e)||n[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return!!(n[t]!==void 0&&n[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const n=this._listeners;if(n[t]===void 0)return this;const s=n[t].indexOf(e);return s!==-1&&n[t].splice(s,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const n=this._listeners[t.type];if(n!==void 0){t.target=this;for(let s=0,i=n.length;s<i;s++)n[s].call(this,t)}return this}}class G{constructor(t,e,n,s){t===void 0&&(t=0),e===void 0&&(e=0),n===void 0&&(n=0),s===void 0&&(s=1),this.x=t,this.y=e,this.z=n,this.w=s}set(t,e,n,s){return this.x=t,this.y=e,this.z=n,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const n=Math.sin(e*.5);return this.x=t.x*n,this.y=t.y*n,this.z=t.z*n,this.w=Math.cos(e*.5),this}toAxisAngle(t){t===void 0&&(t=new a),this.normalize();const e=2*Math.acos(this.w),n=Math.sqrt(1-this.w*this.w);return n<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/n,t.y=this.y/n,t.z=this.z/n),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const n=An,s=zn;t.tangents(n,s),this.setFromAxisAngle(n,Math.PI)}else{const n=t.cross(e);this.x=n.x,this.y=n.y,this.z=n.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){e===void 0&&(e=new G);const n=this.x,s=this.y,i=this.z,o=this.w,r=t.x,c=t.y,l=t.z,d=t.w;return e.x=n*d+o*r+s*l-i*c,e.y=s*d+o*c+i*r-n*l,e.z=i*d+o*l+n*c-s*r,e.w=o*d-n*r-s*c-i*l,e}inverse(t){t===void 0&&(t=new G);const e=this.x,n=this.y,s=this.z,i=this.w;this.conjugate(t);const o=1/(e*e+n*n+s*s+i*i);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return t===void 0&&(t=new G),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){e===void 0&&(e=new a);const n=t.x,s=t.y,i=t.z,o=this.x,r=this.y,c=this.z,l=this.w,d=l*n+r*i-c*s,u=l*s+c*n-o*i,h=l*i+o*s-r*n,p=-o*n-r*s-c*i;return e.x=d*l+p*-o+u*-c-h*-r,e.y=u*l+p*-r+h*-o-d*-c,e.z=h*l+p*-c+d*-r-u*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){e===void 0&&(e="YZX");let n,s,i;const o=this.x,r=this.y,c=this.z,l=this.w;switch(e){case"YZX":const d=o*r+c*l;if(d>.499&&(n=2*Math.atan2(o,l),s=Math.PI/2,i=0),d<-.499&&(n=-2*Math.atan2(o,l),s=-Math.PI/2,i=0),n===void 0){const u=o*o,h=r*r,p=c*c;n=Math.atan2(2*r*l-2*o*c,1-2*h-2*p),s=Math.asin(2*d),i=Math.atan2(2*o*l-2*r*c,1-2*u-2*p)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=n,t.z=s,t.x=i}setFromEuler(t,e,n,s){s===void 0&&(s="XYZ");const i=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(n/2),c=Math.sin(t/2),l=Math.sin(e/2),d=Math.sin(n/2);return s==="XYZ"?(this.x=c*o*r+i*l*d,this.y=i*l*r-c*o*d,this.z=i*o*d+c*l*r,this.w=i*o*r-c*l*d):s==="YXZ"?(this.x=c*o*r+i*l*d,this.y=i*l*r-c*o*d,this.z=i*o*d-c*l*r,this.w=i*o*r+c*l*d):s==="ZXY"?(this.x=c*o*r-i*l*d,this.y=i*l*r+c*o*d,this.z=i*o*d+c*l*r,this.w=i*o*r-c*l*d):s==="ZYX"?(this.x=c*o*r-i*l*d,this.y=i*l*r+c*o*d,this.z=i*o*d-c*l*r,this.w=i*o*r+c*l*d):s==="YZX"?(this.x=c*o*r+i*l*d,this.y=i*l*r+c*o*d,this.z=i*o*d-c*l*r,this.w=i*o*r-c*l*d):s==="XZY"&&(this.x=c*o*r-i*l*d,this.y=i*l*r-c*o*d,this.z=i*o*d+c*l*r,this.w=i*o*r+c*l*d),this}clone(){return new G(this.x,this.y,this.z,this.w)}slerp(t,e,n){n===void 0&&(n=new G);const s=this.x,i=this.y,o=this.z,r=this.w;let c=t.x,l=t.y,d=t.z,u=t.w,h,p,m,w,v;return p=s*c+i*l+o*d+r*u,p<0&&(p=-p,c=-c,l=-l,d=-d,u=-u),1-p>1e-6?(h=Math.acos(p),m=Math.sin(h),w=Math.sin((1-e)*h)/m,v=Math.sin(e*h)/m):(w=1-e,v=e),n.x=w*s+v*c,n.y=w*i+v*l,n.z=w*o+v*d,n.w=w*r+v*u,n}integrate(t,e,n,s){s===void 0&&(s=new G);const i=t.x*n.x,o=t.y*n.y,r=t.z*n.z,c=this.x,l=this.y,d=this.z,u=this.w,h=e*.5;return s.x+=h*(i*u+o*d-r*l),s.y+=h*(o*u+r*c-i*d),s.z+=h*(r*u+i*l-o*c),s.w+=h*(-i*c-o*l-r*d),s}}const An=new a,zn=new a,Cn={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class B{constructor(t){t===void 0&&(t={}),this.id=B.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,n,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}B.idCounter=0;B.types=Cn;class D{constructor(t){t===void 0&&(t={}),this.position=new a,this.quaternion=new G,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return D.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return D.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return e===void 0&&(e=new a),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,n,s){return s===void 0&&(s=new a),n.vsub(t,s),e.conjugate(Se),Se.vmult(s,s),s}static pointToWorldFrame(t,e,n,s){return s===void 0&&(s=new a),e.vmult(n,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,n){return n===void 0&&(n=new a),t.vmult(e,n),n}static vectorToLocalFrame(t,e,n,s){return s===void 0&&(s=new a),e.w*=-1,e.vmult(n,s),e.w*=-1,s}}const Se=new G;class Lt extends B{constructor(t){t===void 0&&(t={});const{vertices:e=[],faces:n=[],normals:s=[],axes:i,boundingSphereRadius:o}=t;super({type:B.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=n,this.faceNormals=s,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,n=this.uniqueEdges;n.length=0;const s=new a;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let c=0;c!==r;c++){const l=(c+1)%r;e[o[c]].vsub(e[o[l]],s),s.normalize();let d=!1;for(let u=0;u!==n.length;u++)if(n[u].almostEquals(s)||n[u].almostEquals(s)){d=!0;break}d||n.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let s=0;s<this.faces[t].length;s++)if(!this.vertices[this.faces[t][s]])throw new Error(`Vertex ${this.faces[t][s]} not found!`);const e=this.faceNormals[t]||new a;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const n=this.vertices[this.faces[t][0]];if(e.dot(n)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let s=0;s<this.faces[t].length;s++)console.warn(`.vertices[${this.faces[t][s]}] = Vec3(${this.vertices[this.faces[t][s]].toString()})`)}}}getFaceNormal(t,e){const n=this.faces[t],s=this.vertices[n[0]],i=this.vertices[n[1]],o=this.vertices[n[2]];Lt.computeNormal(s,i,o,e)}static computeNormal(t,e,n,s){const i=new a,o=new a;e.vsub(t,o),n.vsub(e,i),i.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,n,s,i,o,r,c,l){const d=new a;let u=-1,h=-Number.MAX_VALUE;for(let m=0;m<n.faces.length;m++){d.copy(n.faceNormals[m]),i.vmult(d,d);const w=d.dot(o);w>h&&(h=w,u=m)}const p=[];for(let m=0;m<n.faces[u].length;m++){const w=n.vertices[n.faces[u][m]],v=new a;v.copy(w),i.vmult(v,v),s.vadd(v,v),p.push(v)}u>=0&&this.clipFaceAgainstHull(o,t,e,p,r,c,l)}findSeparatingAxis(t,e,n,s,i,o,r,c){const l=new a,d=new a,u=new a,h=new a,p=new a,m=new a;let w=Number.MAX_VALUE;const v=this;if(v.uniqueAxes)for(let g=0;g!==v.uniqueAxes.length;g++){n.vmult(v.uniqueAxes[g],l);const f=v.testSepAxis(l,t,e,n,s,i);if(f===!1)return!1;f<w&&(w=f,o.copy(l))}else{const g=r?r.length:v.faces.length;for(let f=0;f<g;f++){const A=r?r[f]:f;l.copy(v.faceNormals[A]),n.vmult(l,l);const b=v.testSepAxis(l,t,e,n,s,i);if(b===!1)return!1;b<w&&(w=b,o.copy(l))}}if(t.uniqueAxes)for(let g=0;g!==t.uniqueAxes.length;g++){i.vmult(t.uniqueAxes[g],d);const f=v.testSepAxis(d,t,e,n,s,i);if(f===!1)return!1;f<w&&(w=f,o.copy(d))}else{const g=c?c.length:t.faces.length;for(let f=0;f<g;f++){const A=c?c[f]:f;d.copy(t.faceNormals[A]),i.vmult(d,d);const b=v.testSepAxis(d,t,e,n,s,i);if(b===!1)return!1;b<w&&(w=b,o.copy(d))}}for(let g=0;g!==v.uniqueEdges.length;g++){n.vmult(v.uniqueEdges[g],h);for(let f=0;f!==t.uniqueEdges.length;f++)if(i.vmult(t.uniqueEdges[f],p),h.cross(p,m),!m.almostZero()){m.normalize();const A=v.testSepAxis(m,t,e,n,s,i);if(A===!1)return!1;A<w&&(w=A,o.copy(m))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,n,s,i,o){const r=this;Lt.project(r,t,n,s,ee),Lt.project(e,t,i,o,ne);const c=ee[0],l=ee[1],d=ne[0],u=ne[1];if(c<u||d<l)return!1;const h=c-u,p=d-l;return h<p?h:p}calculateLocalInertia(t,e){const n=new a,s=new a;this.computeLocalAABB(s,n);const i=n.x-s.x,o=n.y-s.y,r=n.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*i*2*i+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*i*2*i)}getPlaneConstantOfFace(t){const e=this.faces[t],n=this.faceNormals[t],s=this.vertices[e[0]];return-n.dot(s)}clipFaceAgainstHull(t,e,n,s,i,o,r){const c=new a,l=new a,d=new a,u=new a,h=new a,p=new a,m=new a,w=new a,v=this,g=[],f=s,A=g;let b=-1,E=Number.MAX_VALUE;for(let N=0;N<v.faces.length;N++){c.copy(v.faceNormals[N]),n.vmult(c,c);const P=c.dot(t);P<E&&(E=P,b=N)}if(b<0)return;const _=v.faces[b];_.connectedFaces=[];for(let N=0;N<v.faces.length;N++)for(let P=0;P<v.faces[N].length;P++)_.indexOf(v.faces[N][P])!==-1&&N!==b&&_.connectedFaces.indexOf(N)===-1&&_.connectedFaces.push(N);const M=_.length;for(let N=0;N<M;N++){const P=v.vertices[_[N]],I=v.vertices[_[(N+1)%M]];P.vsub(I,l),d.copy(l),n.vmult(d,d),e.vadd(d,d),u.copy(this.faceNormals[b]),n.vmult(u,u),e.vadd(u,u),d.cross(u,h),h.negate(h),p.copy(P),n.vmult(p,p),e.vadd(p,p);const z=_.connectedFaces[N];m.copy(this.faceNormals[z]);const S=this.getPlaneConstantOfFace(z);w.copy(m),n.vmult(w,w);const T=S-w.dot(e);for(this.clipFaceAgainstPlane(f,A,w,T);f.length;)f.shift();for(;A.length;)f.push(A.shift())}m.copy(this.faceNormals[b]);const R=this.getPlaneConstantOfFace(b);w.copy(m),n.vmult(w,w);const O=R-w.dot(e);for(let N=0;N<f.length;N++){let P=w.dot(f[N])+O;if(P<=i&&(console.log(`clamped: depth=${P} to minDist=${i}`),P=i),P<=o){const I=f[N];if(P<=1e-6){const z={point:I,normal:w,depth:P};r.push(z)}}}}clipFaceAgainstPlane(t,e,n,s){let i,o;const r=t.length;if(r<2)return e;let c=t[t.length-1],l=t[0];i=n.dot(c)+s;for(let d=0;d<r;d++){if(l=t[d],o=n.dot(l)+s,i<0)if(o<0){const u=new a;u.copy(l),e.push(u)}else{const u=new a;c.lerp(l,i/(i-o),u),e.push(u)}else if(o<0){const u=new a;c.lerp(l,i/(i-o),u),e.push(u),e.push(l)}c=l,i=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new a);const n=this.vertices,s=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(n[i],s[i]),t.vadd(s[i],s[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const n=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){const i=n[s];i.x<t.x?t.x=i.x:i.x>e.x&&(e.x=i.x),i.y<t.y?t.y=i.y:i.y>e.y&&(e.y=i.y),i.z<t.z?t.z=i.z:i.z>e.z&&(e.z=i.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new a);const n=this.faceNormals,s=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(n[i],s[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let n=0;n!==e.length;n++){const s=e[n].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,n,s){const i=this.vertices;let o,r,c,l,d,u,h=new a;for(let p=0;p<i.length;p++){h.copy(i[p]),e.vmult(h,h),t.vadd(h,h);const m=h;(o===void 0||m.x<o)&&(o=m.x),(l===void 0||m.x>l)&&(l=m.x),(r===void 0||m.y<r)&&(r=m.y),(d===void 0||m.y>d)&&(d=m.y),(c===void 0||m.z<c)&&(c=m.z),(u===void 0||m.z>u)&&(u=m.z)}n.set(o,r,c),s.set(l,d,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){t===void 0&&(t=new a);const e=this.vertices;for(let n=0;n<e.length;n++)t.vadd(e[n],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const n=this.vertices.length,s=this.vertices;if(e){for(let i=0;i<n;i++){const o=s[i];e.vmult(o,o)}for(let i=0;i<this.faceNormals.length;i++){const o=this.faceNormals[i];e.vmult(o,o)}}if(t)for(let i=0;i<n;i++){const o=s[i];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,n=this.faces,s=this.faceNormals,i=new a;this.getAveragePointLocal(i);for(let o=0;o<this.faces.length;o++){let r=s[o];const c=e[n[o][0]],l=new a;t.vsub(c,l);const d=r.dot(l),u=new a;i.vsub(c,u);const h=r.dot(u);if(d<0&&h>0||d>0&&h<0)return!1}return-1}static project(t,e,n,s,i){const o=t.vertices.length,r=_n;let c=0,l=0;const d=Mn,u=t.vertices;d.setZero(),D.vectorToLocalFrame(n,s,e,r),D.pointToLocalFrame(n,s,d,d);const h=d.dot(r);l=c=u[0].dot(r);for(let p=1;p<o;p++){const m=u[p].dot(r);m>c&&(c=m),m<l&&(l=m)}if(l-=h,c-=h,l>c){const p=l;l=c,c=p}i[0]=c,i[1]=l}}const ee=[],ne=[];new a;const _n=new a,Mn=new a;class Vt extends B{constructor(t){super({type:B.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,n=this.halfExtents.z,s=a,i=[new s(-t,-e,-n),new s(t,-e,-n),new s(t,e,-n),new s(-t,e,-n),new s(-t,-e,n),new s(t,-e,n),new s(t,e,n),new s(-t,e,n)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new s(0,0,1),new s(0,1,0),new s(1,0,0)],c=new Lt({vertices:i,faces:o,axes:r});this.convexPolyhedronRepresentation=c,c.material=this.material}calculateLocalInertia(t,e){return e===void 0&&(e=new a),Vt.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,n){const s=t;n.x=1/12*e*(2*s.y*2*s.y+2*s.z*2*s.z),n.y=1/12*e*(2*s.x*2*s.x+2*s.z*2*s.z),n.z=1/12*e*(2*s.y*2*s.y+2*s.x*2*s.x)}getSideNormals(t,e){const n=t,s=this.halfExtents;if(n[0].set(s.x,0,0),n[1].set(0,s.y,0),n[2].set(0,0,s.z),n[3].set(-s.x,0,0),n[4].set(0,-s.y,0),n[5].set(0,0,-s.z),e!==void 0)for(let i=0;i!==n.length;i++)e.vmult(n[i],n[i]);return n}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,n){const s=this.halfExtents,i=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let o=0;o<i.length;o++)pt.set(i[o][0],i[o][1],i[o][2]),e.vmult(pt,pt),t.vadd(pt,pt),n(pt.x,pt.y,pt.z)}calculateWorldAABB(t,e,n,s){const i=this.halfExtents;ot[0].set(i.x,i.y,i.z),ot[1].set(-i.x,i.y,i.z),ot[2].set(-i.x,-i.y,i.z),ot[3].set(-i.x,-i.y,-i.z),ot[4].set(i.x,-i.y,-i.z),ot[5].set(i.x,i.y,-i.z),ot[6].set(-i.x,i.y,-i.z),ot[7].set(i.x,-i.y,i.z);const o=ot[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),n.copy(o);for(let r=1;r<8;r++){const c=ot[r];e.vmult(c,c),t.vadd(c,c);const l=c.x,d=c.y,u=c.z;l>s.x&&(s.x=l),d>s.y&&(s.y=d),u>s.z&&(s.z=u),l<n.x&&(n.x=l),d<n.y&&(n.y=d),u<n.z&&(n.z=u)}}}const pt=new a,ot=[new a,new a,new a,new a,new a,new a,new a,new a],pe={DYNAMIC:1,STATIC:2,KINEMATIC:4},me={AWAKE:0,SLEEPY:1,SLEEPING:2};class F extends Qe{constructor(t){t===void 0&&(t={}),super(),this.id=F.idCounter++,this.index=-1,this.world=null,this.vlambda=new a,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new a,this.previousPosition=new a,this.interpolatedPosition=new a,this.initPosition=new a,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new a,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new a,this.force=new a;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep<"u"?t.allowSleep:!0,this.sleepState=F.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit<"u"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit<"u"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new a,this.quaternion=new G,this.initQuaternion=new G,this.previousQuaternion=new G,this.interpolatedQuaternion=new G,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new a,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new a,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new a,this.invInertia=new a,this.invInertiaWorld=new nt,this.invMassSolve=0,this.invInertiaSolve=new a,this.invInertiaWorldSolve=new nt,this.fixedRotation=typeof t.fixedRotation<"u"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping<"u"?t.angularDamping:.01,this.linearFactor=new a(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new a(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new tt,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new a,this.isTrigger=!!t.isTrigger,t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,n=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===F.AWAKE&&n<s?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):e===F.SLEEPY&&n>s?this.wakeUp():e===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return e===void 0&&(e=new a),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return e===void 0&&(e=new a),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return e===void 0&&(e=new a),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return e===void 0&&(e=new a),this.quaternion.vmult(t,e),e}addShape(t,e,n){const s=new a,i=new G;return e&&s.copy(e),n&&i.copy(n),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,n=t.length;let s=0;for(let i=0;i!==n;i++){const o=t[i];o.updateBoundingSphereRadius();const r=e[i].length(),c=o.boundingSphereRadius;r+c>s&&(s=r+c)}this.boundingRadius=s}updateAABB(){const t=this.shapes,e=this.shapeOffsets,n=this.shapeOrientations,s=t.length,i=Tn,o=Sn,r=this.quaternion,c=this.aabb,l=Fn;for(let d=0;d!==s;d++){const u=t[d];r.vmult(e[d],i),i.vadd(this.position,i),r.mult(n[d],o),u.calculateWorldAABB(i,o,l.lowerBound,l.upperBound),d===0?c.copy(l):c.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const n=Bn,s=Rn;n.setRotationFromQuaternion(this.quaternion),n.transpose(s),n.scale(e,n),n.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(e===void 0&&(e=new a),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=Pn;e.cross(t,n),this.force.vadd(t,this.force),this.torque.vadd(n,this.torque)}applyLocalForce(t,e){if(e===void 0&&(e=new a),this.type!==F.DYNAMIC)return;const n=Nn,s=In;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyForce(n,s)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(e===void 0&&(e=new a),this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const n=e,s=Ln;s.copy(t),s.scale(this.invMass,s),this.velocity.vadd(s,this.velocity);const i=qn;n.cross(t,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(t,e){if(e===void 0&&(e=new a),this.type!==F.DYNAMIC)return;const n=On,s=Vn;this.vectorToWorldFrame(t,n),this.vectorToWorldFrame(e,s),this.applyImpulse(n,s)}updateMassProperties(){const t=Wn;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,n=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Vt.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!n?1/e.x:0,e.y>0&&!n?1/e.y:0,e.z>0&&!n?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const n=new a;return t.vsub(this.position,n),this.angularVelocity.cross(n,e),this.velocity.vadd(e,e),e}integrate(t,e,n){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===F.DYNAMIC||this.type===F.KINEMATIC)||this.sleepState===F.SLEEPING)return;const s=this.velocity,i=this.angularVelocity,o=this.position,r=this.force,c=this.torque,l=this.quaternion,d=this.invMass,u=this.invInertiaWorld,h=this.linearFactor,p=d*t;s.x+=r.x*p*h.x,s.y+=r.y*p*h.y,s.z+=r.z*p*h.z;const m=u.elements,w=this.angularFactor,v=c.x*w.x,g=c.y*w.y,f=c.z*w.z;i.x+=t*(m[0]*v+m[1]*g+m[2]*f),i.y+=t*(m[3]*v+m[4]*g+m[5]*f),i.z+=t*(m[6]*v+m[7]*g+m[8]*f),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,l.integrate(this.angularVelocity,t,this.angularFactor,l),e&&(n?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0;F.COLLIDE_EVENT_NAME="collide";F.DYNAMIC=pe.DYNAMIC;F.STATIC=pe.STATIC;F.KINEMATIC=pe.KINEMATIC;F.AWAKE=me.AWAKE;F.SLEEPY=me.SLEEPY;F.SLEEPING=me.SLEEPING;F.wakeupEvent={type:"wakeup"};F.sleepyEvent={type:"sleepy"};F.sleepEvent={type:"sleep"};const Tn=new a,Sn=new G,Fn=new tt,Bn=new nt,Rn=new nt;new nt;const Pn=new a,Nn=new a,In=new a,Ln=new a,qn=new a,On=new a,Vn=new a,Wn=new a;class Je{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,n){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!(!(t.collisionFilterGroup&e.collisionFilterMask)||!(e.collisionFilterGroup&t.collisionFilterMask)||(t.type&F.STATIC||t.sleepState===F.SLEEPING)&&(e.type&F.STATIC||e.sleepState===F.SLEEPING))}intersectionTest(t,e,n,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,n,s):this.doBoundingSphereBroadphase(t,e,n,s)}doBoundingSphereBroadphase(t,e,n,s){const i=Dn;e.position.vsub(t.position,i);const o=(t.boundingRadius+e.boundingRadius)**2;i.lengthSquared()<o&&(n.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,n,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(n.push(t),s.push(e))}makePairsUnique(t,e){const n=kn,s=jn,i=Hn,o=t.length;for(let r=0;r!==o;r++)s[r]=t[r],i[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const c=s[r].id,l=i[r].id,d=c<l?`${c},${l}`:`${l},${c}`;n[d]=r,n.keys.push(d)}for(let r=0;r!==n.keys.length;r++){const c=n.keys.pop(),l=n[c];t.push(s[l]),e.push(i[l]),delete n[c]}}setWorld(t){}static boundingSphereCheck(t,e){const n=new a;t.position.vsub(e.position,n);const s=t.shapes[0],i=e.shapes[0];return Math.pow(s.boundingSphereRadius+i.boundingSphereRadius,2)>n.lengthSquared()}aabbQuery(t,e,n){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Dn=new a;new a;new G;new a;const kn={keys:[]},jn=[],Hn=[];new a;new a;new a;class Un extends Je{constructor(){super()}collisionPairs(t,e,n){const s=t.bodies,i=s.length;let o,r;for(let c=0;c!==i;c++)for(let l=0;l!==c;l++)o=s[c],r=s[l],this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,n)}aabbQuery(t,e,n){n===void 0&&(n=[]);for(let s=0;s<t.bodies.length;s++){const i=t.bodies[s];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(e)&&n.push(i)}return n}}class Kt{constructor(){this.rayFromWorld=new a,this.rayToWorld=new a,this.hitNormalWorld=new a,this.hitPointWorld=new a,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,n,s,i,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(n),this.hitPointWorld.copy(s),this.shape=i,this.body=o,this.distance=r}}let tn,en,nn,sn,on,rn,cn;const ve={CLOSEST:1,ANY:2,ALL:4};tn=B.types.SPHERE;en=B.types.PLANE;nn=B.types.BOX;sn=B.types.CYLINDER;on=B.types.CONVEXPOLYHEDRON;rn=B.types.HEIGHTFIELD;cn=B.types.TRIMESH;class U{get[tn](){return this._intersectSphere}get[en](){return this._intersectPlane}get[nn](){return this._intersectBox}get[sn](){return this._intersectConvex}get[on](){return this._intersectConvex}get[rn](){return this._intersectHeightfield}get[cn](){return this._intersectTrimesh}constructor(t,e){t===void 0&&(t=new a),e===void 0&&(e=new a),this.from=t.clone(),this.to=e.clone(),this.direction=new a,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=U.ANY,this.result=new Kt,this.hasHit=!1,this.callback=n=>{}}intersectWorld(t,e){return this.mode=e.mode||U.ANY,this.result=e.result||new Kt,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask<"u"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup<"u"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse<"u"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(Fe),se.length=0,t.broadphase.aabbQuery(t,Fe,se),this.intersectBodies(se),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const n=this.checkCollisionResponse;if(n&&!t.collisionResponse||!(this.collisionFilterGroup&t.collisionFilterMask)||!(t.collisionFilterGroup&this.collisionFilterMask))return;const s=Gn,i=Yn;for(let o=0,r=t.shapes.length;o<r;o++){const c=t.shapes[o];if(!(n&&!c.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],i),t.quaternion.vmult(t.shapeOffsets[o],s),s.vadd(t.position,s),this.intersectShape(c,i,s,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let n=0,s=t.length;!this.result.shouldStop&&n<s;n++)this.intersectBody(t[n])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,n,s){const i=this.from;if(cs(i,this.direction,n)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,n,s,t)}_intersectBox(t,e,n,s,i){return this._intersectConvex(t.convexPolyhedronRepresentation,e,n,s,i)}_intersectPlane(t,e,n,s,i){const o=this.from,r=this.to,c=this.direction,l=new a(0,0,1);e.vmult(l,l);const d=new a;o.vsub(n,d);const u=d.dot(l);r.vsub(n,d);const h=d.dot(l);if(u*h>0||o.distanceTo(r)<u)return;const p=l.dot(c);if(Math.abs(p)<this.precision)return;const m=new a,w=new a,v=new a;o.vsub(n,m);const g=-l.dot(m)/p;c.scale(g,w),o.vadd(w,v),this.reportIntersection(l,v,i,s,-1)}getAABB(t){const{lowerBound:e,upperBound:n}=t,s=this.to,i=this.from;e.x=Math.min(s.x,i.x),e.y=Math.min(s.y,i.y),e.z=Math.min(s.z,i.z),n.x=Math.max(s.x,i.x),n.y=Math.max(s.y,i.y),n.z=Math.max(s.z,i.z)}_intersectHeightfield(t,e,n,s,i){t.data,t.elementSize;const o=Xn;o.from.copy(this.from),o.to.copy(this.to),D.pointToLocalFrame(n,e,o.from,o.from),D.pointToLocalFrame(n,e,o.to,o.to),o.updateDirection();const r=$n;let c,l,d,u;c=l=0,d=u=t.data.length-1;const h=new tt;o.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,r,!0),c=Math.max(c,r[0]),l=Math.max(l,r[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,r,!0),d=Math.min(d,r[0]+1),u=Math.min(u,r[1]+1);for(let p=c;p<d;p++)for(let m=l;m<u;m++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(p,m,h),!!h.overlapsRay(o)){if(t.getConvexTrianglePillar(p,m,!1),D.pointToWorldFrame(n,e,t.pillarOffset,kt),this._intersectConvex(t.pillarConvex,e,kt,s,i,Be),this.result.shouldStop)return;t.getConvexTrianglePillar(p,m,!0),D.pointToWorldFrame(n,e,t.pillarOffset,kt),this._intersectConvex(t.pillarConvex,e,kt,s,i,Be)}}}_intersectSphere(t,e,n,s,i){const o=this.from,r=this.to,c=t.radius,l=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,d=2*((r.x-o.x)*(o.x-n.x)+(r.y-o.y)*(o.y-n.y)+(r.z-o.z)*(o.z-n.z)),u=(o.x-n.x)**2+(o.y-n.y)**2+(o.z-n.z)**2-c**2,h=d**2-4*l*u,p=Zn,m=Kn;if(!(h<0))if(h===0)o.lerp(r,h,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1);else{const w=(-d-Math.sqrt(h))/(2*l),v=(-d+Math.sqrt(h))/(2*l);if(w>=0&&w<=1&&(o.lerp(r,w,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1)),this.result.shouldStop)return;v>=0&&v<=1&&(o.lerp(r,v,p),p.vsub(n,m),m.normalize(),this.reportIntersection(m,p,i,s,-1))}}_intersectConvex(t,e,n,s,i,o){const r=Qn,c=Re,l=o&&o.faceList||null,d=t.faces,u=t.vertices,h=t.faceNormals,p=this.direction,m=this.from,w=this.to,v=m.distanceTo(w),g=l?l.length:d.length,f=this.result;for(let A=0;!f.shouldStop&&A<g;A++){const b=l?l[A]:A,E=d[b],_=h[b],M=e,R=n;c.copy(u[E[0]]),M.vmult(c,c),c.vadd(R,c),c.vsub(m,c),M.vmult(_,r);const O=p.dot(r);if(Math.abs(O)<this.precision)continue;const N=r.dot(c)/O;if(!(N<0)){p.scale(N,J),J.vadd(m,J),et.copy(u[E[0]]),M.vmult(et,et),R.vadd(et,et);for(let P=1;!f.shouldStop&&P<E.length-1;P++){rt.copy(u[E[P]]),ct.copy(u[E[P+1]]),M.vmult(rt,rt),M.vmult(ct,ct),R.vadd(rt,rt),R.vadd(ct,ct);const I=J.distanceTo(m);!(U.pointInTriangle(J,et,rt,ct)||U.pointInTriangle(J,rt,et,ct))||I>v||this.reportIntersection(r,J,i,s,b)}}}}_intersectTrimesh(t,e,n,s,i,o){const r=Jn,c=os,l=rs,d=Re,u=ts,h=es,p=ns,m=is,w=ss,v=t.indices;t.vertices;const g=this.from,f=this.to,A=this.direction;l.position.copy(n),l.quaternion.copy(e),D.vectorToLocalFrame(n,e,A,u),D.pointToLocalFrame(n,e,g,h),D.pointToLocalFrame(n,e,f,p),p.x*=t.scale.x,p.y*=t.scale.y,p.z*=t.scale.z,h.x*=t.scale.x,h.y*=t.scale.y,h.z*=t.scale.z,p.vsub(h,u),u.normalize();const b=h.distanceSquared(p);t.tree.rayQuery(this,l,c);for(let E=0,_=c.length;!this.result.shouldStop&&E!==_;E++){const M=c[E];t.getNormal(M,r),t.getVertex(v[M*3],et),et.vsub(h,d);const R=u.dot(r),O=r.dot(d)/R;if(O<0)continue;u.scale(O,J),J.vadd(h,J),t.getVertex(v[M*3+1],rt),t.getVertex(v[M*3+2],ct);const N=J.distanceSquared(h);!(U.pointInTriangle(J,rt,et,ct)||U.pointInTriangle(J,et,rt,ct))||N>b||(D.vectorToWorldFrame(e,r,w),D.pointToWorldFrame(n,e,J,m),this.reportIntersection(w,m,i,s,M))}c.length=0}reportIntersection(t,e,n,s,i){const o=this.from,r=this.to,c=o.distanceTo(e),l=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(l.hitFaceIndex=typeof i<"u"?i:-1,this.mode){case U.ALL:this.hasHit=!0,l.set(o,r,t,e,n,s,c),l.hasHit=!0,this.callback(l);break;case U.CLOSEST:(c<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(o,r,t,e,n,s,c));break;case U.ANY:this.hasHit=!0,l.hasHit=!0,l.set(o,r,t,e,n,s,c),l.shouldStop=!0;break}}static pointInTriangle(t,e,n,s){s.vsub(e,vt),n.vsub(e,Rt),t.vsub(e,ie);const i=vt.dot(vt),o=vt.dot(Rt),r=vt.dot(ie),c=Rt.dot(Rt),l=Rt.dot(ie);let d,u;return(d=c*r-o*l)>=0&&(u=i*l-o*r)>=0&&d+u<i*c-o*o}}U.CLOSEST=ve.CLOSEST;U.ANY=ve.ANY;U.ALL=ve.ALL;const Fe=new tt,se=[],Rt=new a,ie=new a,Gn=new a,Yn=new G,J=new a,et=new a,rt=new a,ct=new a;new a;new Kt;const Be={faceList:[0]},kt=new a,Xn=new U,$n=[],Zn=new a,Kn=new a,Qn=new a;new a;new a;const Re=new a,Jn=new a,ts=new a,es=new a,ns=new a,ss=new a,is=new a;new tt;const os=[],rs=new D,vt=new a,jt=new a;function cs(x,t,e){e.vsub(x,vt);const n=vt.dot(t);return t.scale(n,jt),jt.vadd(x,jt),e.distanceTo(jt)}class zt extends Je{static checkBounds(t,e,n){let s,i;n===0?(s=t.position.x,i=e.position.x):n===1?(s=t.position.y,i=e.position.y):n===2&&(s=t.position.z,i=e.position.z);const o=t.boundingRadius,r=e.boundingRadius,c=s+o;return i-r<c}static insertionSortX(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.x<=s.aabb.lowerBound.x);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortY(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.y<=s.aabb.lowerBound.y);i--)t[i+1]=t[i];t[i+1]=s}return t}static insertionSortZ(t){for(let e=1,n=t.length;e<n;e++){const s=t[e];let i;for(i=e-1;i>=0&&!(t[i].aabb.lowerBound.z<=s.aabb.lowerBound.z);i--)t[i+1]=t[i];t[i+1]=s}return t}constructor(t){super(),this.axisList=[],this.world=null,this.axisIndex=0;const e=this.axisList;this._addBodyHandler=n=>{e.push(n.body)},this._removeBodyHandler=n=>{const s=e.indexOf(n.body);s!==-1&&e.splice(s,1)},t&&this.setWorld(t)}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}collisionPairs(t,e,n){const s=this.axisList,i=s.length,o=this.axisIndex;let r,c;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==i;r++){const l=s[r];for(c=r+1;c<i;c++){const d=s[c];if(this.needBroadphaseCollision(l,d)){if(!zt.checkBounds(l,d,o))break;this.intersectionTest(l,d,e,n)}}}}sortList(){const t=this.axisList,e=this.axisIndex,n=t.length;for(let s=0;s!==n;s++){const i=t[s];i.aabbNeedsUpdate&&i.updateAABB()}e===0?zt.insertionSortX(t):e===1?zt.insertionSortY(t):e===2&&zt.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,n=0,s=0,i=0,o=0;const r=this.axisList,c=r.length,l=1/c;for(let p=0;p!==c;p++){const m=r[p],w=m.position.x;t+=w,e+=w*w;const v=m.position.y;n+=v,s+=v*v;const g=m.position.z;i+=g,o+=g*g}const d=e-t*t*l,u=s-n*n*l,h=o-i*i*l;d>u?d>h?this.axisIndex=0:this.axisIndex=2:u>h?this.axisIndex=1:this.axisIndex=2}aabbQuery(t,e,n){n===void 0&&(n=[]),this.dirty&&(this.sortList(),this.dirty=!1);const s=this.axisIndex;let i="x";s===1&&(i="y"),s===2&&(i="z");const o=this.axisList;e.lowerBound[i],e.upperBound[i];for(let r=0;r<o.length;r++){const c=o[r];c.aabbNeedsUpdate&&c.updateAABB(),c.aabb.overlaps(e)&&n.push(c)}return n}}class as{static defaults(t,e){t===void 0&&(t={});for(let n in e)n in t||(t[n]=e[n]);return t}}class Pe{constructor(){this.spatial=new a,this.rotational=new a}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class Wt{constructor(t,e,n,s){n===void 0&&(n=-1e6),s===void 0&&(s=1e6),this.id=Wt.idCounter++,this.minForce=n,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new Pe,this.jacobianElementB=new Pe,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,n){const s=e,i=t,o=n;this.a=4/(o*(1+4*s)),this.b=4*s/(1+4*s),this.eps=4/(o*o*i*(1+4*s))}computeB(t,e,n){const s=this.computeGW(),i=this.computeGq(),o=this.computeGiMf();return-i*t-s*e-o*n}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.position,o=s.position;return t.spatial.dot(i)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.velocity,o=s.velocity,r=n.angularVelocity,c=s.angularVelocity;return t.multiplyVectors(i,r)+e.multiplyVectors(o,c)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.vlambda,o=s.vlambda,r=n.wlambda,c=s.wlambda;return t.multiplyVectors(i,r)+e.multiplyVectors(o,c)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.force,o=n.torque,r=s.force,c=s.torque,l=n.invMassSolve,d=s.invMassSolve;return i.scale(l,Ne),r.scale(d,Ie),n.invInertiaWorldSolve.vmult(o,Le),s.invInertiaWorldSolve.vmult(c,qe),t.multiplyVectors(Ne,Le)+e.multiplyVectors(Ie,qe)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,n=this.bi,s=this.bj,i=n.invMassSolve,o=s.invMassSolve,r=n.invInertiaWorldSolve,c=s.invInertiaWorldSolve;let l=i+o;return r.vmult(t.rotational,Ht),l+=Ht.dot(t.rotational),c.vmult(e.rotational,Ht),l+=Ht.dot(e.rotational),l}addToWlambda(t){const e=this.jacobianElementA,n=this.jacobianElementB,s=this.bi,i=this.bj,o=ls;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),i.vlambda.addScaledVector(i.invMassSolve*t,n.spatial,i.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,o),s.wlambda.addScaledVector(t,o,s.wlambda),i.invInertiaWorldSolve.vmult(n.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Wt.idCounter=0;const Ne=new a,Ie=new a,Le=new a,qe=new a,Ht=new a,ls=new a;class hs extends Wt{constructor(t,e,n){n===void 0&&(n=1e6),super(t,e,0,n),this.restitution=0,this.ri=new a,this.rj=new a,this.ni=new a}computeB(t){const e=this.a,n=this.b,s=this.bi,i=this.bj,o=this.ri,r=this.rj,c=ds,l=us,d=s.velocity,u=s.angularVelocity;s.force,s.torque;const h=i.velocity,p=i.angularVelocity;i.force,i.torque;const m=fs,w=this.jacobianElementA,v=this.jacobianElementB,g=this.ni;o.cross(g,c),r.cross(g,l),g.negate(w.spatial),c.negate(w.rotational),v.spatial.copy(g),v.rotational.copy(l),m.copy(i.position),m.vadd(r,m),m.vsub(s.position,m),m.vsub(o,m);const f=g.dot(m),A=this.restitution+1,b=A*h.dot(g)-A*d.dot(g)+p.dot(l)-u.dot(c),E=this.computeGiMf();return-f*e-b*n-t*E}getImpactVelocityAlongNormal(){const t=ps,e=ms,n=vs,s=ys,i=ws;return this.bi.position.vadd(this.ri,n),this.bj.position.vadd(this.rj,s),this.bi.getVelocityAtWorldPoint(n,t),this.bj.getVelocityAtWorldPoint(s,e),t.vsub(e,i),this.ni.dot(i)}}const ds=new a,us=new a,fs=new a,ps=new a,ms=new a,vs=new a,ys=new a,ws=new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;class Oe extends Wt{constructor(t,e,n){super(t,e,-n,n),this.ri=new a,this.rj=new a,this.t=new a}computeB(t){this.a;const e=this.b;this.bi,this.bj;const n=this.ri,s=this.rj,i=xs,o=gs,r=this.t;n.cross(r,i),s.cross(r,o);const c=this.jacobianElementA,l=this.jacobianElementB;r.negate(c.spatial),i.negate(c.rotational),l.spatial.copy(r),l.rotational.copy(o);const d=this.computeGW(),u=this.computeGiMf();return-d*e-t*u}}const xs=new a,gs=new a;class Tt{constructor(t,e,n){n=as.defaults(n,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Tt.idCounter++,this.materials=[t,e],this.friction=n.friction,this.restitution=n.restitution,this.contactEquationStiffness=n.contactEquationStiffness,this.contactEquationRelaxation=n.contactEquationRelaxation,this.frictionEquationStiffness=n.frictionEquationStiffness,this.frictionEquationRelaxation=n.frictionEquationRelaxation}}Tt.idCounter=0;class St{constructor(t){t===void 0&&(t={});let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=St.idCounter++,this.friction=typeof t.friction<"u"?t.friction:-1,this.restitution=typeof t.restitution<"u"?t.restitution:-1}}St.idCounter=0;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new U;new a;new a;new a;new a(1,0,0),new a(0,1,0),new a(0,0,1);new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new tt;new a;new tt;new a;new a;new a;new a;new a;new a;new a;new tt;new a;new D;new tt;class bs{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,n=e.indexOf(t);n!==-1&&e.splice(n,1)}removeAllEquations(){this.equations.length=0}}class Es extends bs{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let n=0;const s=this.iterations,i=this.tolerance*this.tolerance,o=this.equations,r=o.length,c=e.bodies,l=c.length,d=t;let u,h,p,m,w,v;if(r!==0)for(let b=0;b!==l;b++)c[b].updateSolveMassProperties();const g=zs,f=Cs,A=As;g.length=r,f.length=r,A.length=r;for(let b=0;b!==r;b++){const E=o[b];A[b]=0,f[b]=E.computeB(d),g[b]=1/E.computeC()}if(r!==0){for(let _=0;_!==l;_++){const M=c[_],R=M.vlambda,O=M.wlambda;R.set(0,0,0),O.set(0,0,0)}for(n=0;n!==s;n++){m=0;for(let _=0;_!==r;_++){const M=o[_];u=f[_],h=g[_],v=A[_],w=M.computeGWlambda(),p=h*(u-w-M.eps*v),v+p<M.minForce?p=M.minForce-v:v+p>M.maxForce&&(p=M.maxForce-v),A[_]+=p,m+=p>0?p:-p,M.addToWlambda(p)}if(m*m<i)break}for(let _=0;_!==l;_++){const M=c[_],R=M.velocity,O=M.angularVelocity;M.vlambda.vmul(M.linearFactor,M.vlambda),R.vadd(M.vlambda,R),M.wlambda.vmul(M.angularFactor,M.wlambda),O.vadd(M.wlambda,O)}let b=o.length;const E=1/d;for(;b--;)o[b].multiplier=A[b]*E}return n}}const As=[],zs=[],Cs=[];class _s{constructor(){this.objects=[],this.type=Object}release(){const t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class Ms extends _s{constructor(){super(...arguments),this.type=a}constructObject(){return new a}}const k={sphereSphere:B.types.SPHERE,spherePlane:B.types.SPHERE|B.types.PLANE,boxBox:B.types.BOX|B.types.BOX,sphereBox:B.types.SPHERE|B.types.BOX,planeBox:B.types.PLANE|B.types.BOX,convexConvex:B.types.CONVEXPOLYHEDRON,sphereConvex:B.types.SPHERE|B.types.CONVEXPOLYHEDRON,planeConvex:B.types.PLANE|B.types.CONVEXPOLYHEDRON,boxConvex:B.types.BOX|B.types.CONVEXPOLYHEDRON,sphereHeightfield:B.types.SPHERE|B.types.HEIGHTFIELD,boxHeightfield:B.types.BOX|B.types.HEIGHTFIELD,convexHeightfield:B.types.CONVEXPOLYHEDRON|B.types.HEIGHTFIELD,sphereParticle:B.types.PARTICLE|B.types.SPHERE,planeParticle:B.types.PLANE|B.types.PARTICLE,boxParticle:B.types.BOX|B.types.PARTICLE,convexParticle:B.types.PARTICLE|B.types.CONVEXPOLYHEDRON,cylinderCylinder:B.types.CYLINDER,sphereCylinder:B.types.SPHERE|B.types.CYLINDER,planeCylinder:B.types.PLANE|B.types.CYLINDER,boxCylinder:B.types.BOX|B.types.CYLINDER,convexCylinder:B.types.CONVEXPOLYHEDRON|B.types.CYLINDER,heightfieldCylinder:B.types.HEIGHTFIELD|B.types.CYLINDER,particleCylinder:B.types.PARTICLE|B.types.CYLINDER,sphereTrimesh:B.types.SPHERE|B.types.TRIMESH,planeTrimesh:B.types.PLANE|B.types.TRIMESH};class Ts{get[k.sphereSphere](){return this.sphereSphere}get[k.spherePlane](){return this.spherePlane}get[k.boxBox](){return this.boxBox}get[k.sphereBox](){return this.sphereBox}get[k.planeBox](){return this.planeBox}get[k.convexConvex](){return this.convexConvex}get[k.sphereConvex](){return this.sphereConvex}get[k.planeConvex](){return this.planeConvex}get[k.boxConvex](){return this.boxConvex}get[k.sphereHeightfield](){return this.sphereHeightfield}get[k.boxHeightfield](){return this.boxHeightfield}get[k.convexHeightfield](){return this.convexHeightfield}get[k.sphereParticle](){return this.sphereParticle}get[k.planeParticle](){return this.planeParticle}get[k.boxParticle](){return this.boxParticle}get[k.convexParticle](){return this.convexParticle}get[k.cylinderCylinder](){return this.convexConvex}get[k.sphereCylinder](){return this.sphereConvex}get[k.planeCylinder](){return this.planeConvex}get[k.boxCylinder](){return this.boxConvex}get[k.convexCylinder](){return this.convexConvex}get[k.heightfieldCylinder](){return this.heightfieldCylinder}get[k.particleCylinder](){return this.particleCylinder}get[k.sphereTrimesh](){return this.sphereTrimesh}get[k.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Ms,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,n,s,i,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new hs(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&n.collisionResponse&&s.collisionResponse;const c=this.currentContactMaterial;r.restitution=c.restitution,r.setSpookParams(c.contactEquationStiffness,c.contactEquationRelaxation,this.world.dt);const l=n.material||t.material,d=s.material||e.material;return l&&d&&l.restitution>=0&&d.restitution>=0&&(r.restitution=l.restitution*d.restitution),r.si=i||n,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){const n=t.bi,s=t.bj,i=t.si,o=t.sj,r=this.world,c=this.currentContactMaterial;let l=c.friction;const d=i.material||n.material,u=o.material||s.material;if(d&&u&&d.friction>=0&&u.friction>=0&&(l=d.friction*u.friction),l>0){const h=l*(r.frictionGravity||r.gravity).length();let p=n.invMass+s.invMass;p>0&&(p=1/p);const m=this.frictionEquationPool,w=m.length?m.pop():new Oe(n,s,h*p),v=m.length?m.pop():new Oe(n,s,h*p);return w.bi=v.bi=n,w.bj=v.bj=s,w.minForce=v.minForce=-h*p,w.maxForce=v.maxForce=h*p,w.ri.copy(t.ri),w.rj.copy(t.rj),v.ri.copy(t.ri),v.rj.copy(t.rj),t.ni.tangents(w.t,v.t),w.setSpookParams(c.frictionEquationStiffness,c.frictionEquationRelaxation,r.dt),v.setSpookParams(c.frictionEquationStiffness,c.frictionEquationRelaxation,r.dt),w.enabled=v.enabled=t.enabled,e.push(w,v),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const n=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];mt.setZero(),bt.setZero(),Et.setZero();const i=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==i?(mt.vadd(e.ni,mt),bt.vadd(e.ri,bt),Et.vadd(e.rj,Et)):(mt.vsub(e.ni,mt),bt.vadd(e.rj,bt),Et.vadd(e.ri,Et));const o=1/t;bt.scale(o,n.ri),Et.scale(o,n.rj),s.ri.copy(n.ri),s.rj.copy(n.rj),mt.normalize(),mt.tangents(n.t,s.t)}getContacts(t,e,n,s,i,o,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;const c=Bs,l=Rs,d=Ss,u=Fs;for(let h=0,p=t.length;h!==p;h++){const m=t[h],w=e[h];let v=null;m.material&&w.material&&(v=n.getContactMaterial(m.material,w.material)||null);const g=m.type&F.KINEMATIC&&w.type&F.STATIC||m.type&F.STATIC&&w.type&F.KINEMATIC||m.type&F.KINEMATIC&&w.type&F.KINEMATIC;for(let f=0;f<m.shapes.length;f++){m.quaternion.mult(m.shapeOrientations[f],c),m.quaternion.vmult(m.shapeOffsets[f],d),d.vadd(m.position,d);const A=m.shapes[f];for(let b=0;b<w.shapes.length;b++){w.quaternion.mult(w.shapeOrientations[b],l),w.quaternion.vmult(w.shapeOffsets[b],u),u.vadd(w.position,u);const E=w.shapes[b];if(!(A.collisionFilterMask&E.collisionFilterGroup&&E.collisionFilterMask&A.collisionFilterGroup)||d.distanceTo(u)>A.boundingSphereRadius+E.boundingSphereRadius)continue;let _=null;A.material&&E.material&&(_=n.getContactMaterial(A.material,E.material)||null),this.currentContactMaterial=_||v||n.defaultContactMaterial;const M=A.type|E.type,R=this[M];if(R){let O=!1;A.type<E.type?O=R.call(this,A,E,d,u,c,l,m,w,A,E,g):O=R.call(this,E,A,u,d,l,c,w,m,A,E,g),O&&g&&(n.shapeOverlapKeeper.set(A.id,E.id),n.bodyOverlapKeeper.set(m.id,w.id))}}}}}sphereSphere(t,e,n,s,i,o,r,c,l,d,u){if(u)return n.distanceSquared(s)<(t.radius+e.radius)**2;const h=this.createContactEquation(r,c,t,e,l,d);s.vsub(n,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(t.radius,h.ri),h.rj.scale(-e.radius,h.rj),h.ri.vadd(n,h.ri),h.ri.vsub(r.position,h.ri),h.rj.vadd(s,h.rj),h.rj.vsub(c.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(t,e,n,s,i,o,r,c,l,d,u){const h=this.createContactEquation(r,c,t,e,l,d);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(t.radius,h.ri),n.vsub(s,Ut),h.ni.scale(h.ni.dot(Ut),Ve),Ut.vsub(Ve,h.rj),-Ut.dot(h.ni)<=t.radius){if(u)return!0;const p=h.ri,m=h.rj;p.vadd(n,p),p.vsub(r.position,p),m.vadd(s,m),m.vsub(c.position,m),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(t,e,n,s,i,o,r,c,l,d,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,n,s,i,o,r,c,t,e,u)}sphereBox(t,e,n,s,i,o,r,c,l,d,u){const h=this.v3pool,p=ii;n.vsub(s,Gt),e.getSideNormals(p,o);const m=t.radius;let w=!1;const v=ri,g=ci,f=ai;let A=null,b=0,E=0,_=0,M=null;for(let C=0,W=p.length;C!==W&&w===!1;C++){const q=ei;q.copy(p[C]);const V=q.length();q.normalize();const H=Gt.dot(q);if(H<V+m&&H>0){const j=ni,L=si;j.copy(p[(C+1)%3]),L.copy(p[(C+2)%3]);const K=j.length(),st=L.length();j.normalize(),L.normalize();const it=Gt.dot(j),ut=Gt.dot(L);if(it<K&&it>-K&&ut<st&&ut>-st){const ft=Math.abs(H-V-m);if((M===null||ft<M)&&(M=ft,E=it,_=ut,A=V,v.copy(q),g.copy(j),f.copy(L),b++,u))return!0}}}if(b){w=!0;const C=this.createContactEquation(r,c,t,e,l,d);v.scale(-m,C.ri),C.ni.copy(v),C.ni.negate(C.ni),v.scale(A,v),g.scale(E,g),v.vadd(g,v),f.scale(_,f),v.vadd(f,C.rj),C.ri.vadd(n,C.ri),C.ri.vsub(r.position,C.ri),C.rj.vadd(s,C.rj),C.rj.vsub(c.position,C.rj),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult)}let R=h.get();const O=oi;for(let C=0;C!==2&&!w;C++)for(let W=0;W!==2&&!w;W++)for(let q=0;q!==2&&!w;q++)if(R.set(0,0,0),C?R.vadd(p[0],R):R.vsub(p[0],R),W?R.vadd(p[1],R):R.vsub(p[1],R),q?R.vadd(p[2],R):R.vsub(p[2],R),s.vadd(R,O),O.vsub(n,O),O.lengthSquared()<m*m){if(u)return!0;w=!0;const V=this.createContactEquation(r,c,t,e,l,d);V.ri.copy(O),V.ri.normalize(),V.ni.copy(V.ri),V.ri.scale(m,V.ri),V.rj.copy(R),V.ri.vadd(n,V.ri),V.ri.vsub(r.position,V.ri),V.rj.vadd(s,V.rj),V.rj.vsub(c.position,V.rj),this.result.push(V),this.createFrictionEquationsFromContact(V,this.frictionResult)}h.release(R),R=null;const N=h.get(),P=h.get(),I=h.get(),z=h.get(),S=h.get(),T=p.length;for(let C=0;C!==T&&!w;C++)for(let W=0;W!==T&&!w;W++)if(C%3!==W%3){p[W].cross(p[C],N),N.normalize(),p[C].vadd(p[W],P),I.copy(n),I.vsub(P,I),I.vsub(s,I);const q=I.dot(N);N.scale(q,z);let V=0;for(;V===C%3||V===W%3;)V++;S.copy(n),S.vsub(z,S),S.vsub(P,S),S.vsub(s,S);const H=Math.abs(q),j=S.length();if(H<p[V].length()&&j<m){if(u)return!0;w=!0;const L=this.createContactEquation(r,c,t,e,l,d);P.vadd(z,L.rj),L.rj.copy(L.rj),S.negate(L.ni),L.ni.normalize(),L.ri.copy(L.rj),L.ri.vadd(s,L.ri),L.ri.vsub(n,L.ri),L.ri.normalize(),L.ri.scale(m,L.ri),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),L.rj.vadd(s,L.rj),L.rj.vsub(c.position,L.rj),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}}h.release(N,P,I,z,S)}planeBox(t,e,n,s,i,o,r,c,l,d,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,n,s,i,o,r,c,t,e,u)}convexConvex(t,e,n,s,i,o,r,c,l,d,u,h,p){const m=Ai;if(!(n.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,n,i,s,o,m,h,p)){const w=[],v=zi;t.clipAgainstHull(n,i,e,s,o,m,-100,100,w);let g=0;for(let f=0;f!==w.length;f++){if(u)return!0;const A=this.createContactEquation(r,c,t,e,l,d),b=A.ri,E=A.rj;m.negate(A.ni),w[f].normal.negate(v),v.scale(w[f].depth,v),w[f].point.vadd(v,b),E.copy(w[f].point),b.vsub(n,b),E.vsub(s,E),b.vadd(n,b),b.vsub(r.position,b),E.vadd(s,E),E.vsub(c.position,E),this.result.push(A),g++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(A,this.frictionResult)}this.enableFrictionReduction&&g&&this.createFrictionFromAverage(g)}}sphereConvex(t,e,n,s,i,o,r,c,l,d,u){const h=this.v3pool;n.vsub(s,li);const p=e.faceNormals,m=e.faces,w=e.vertices,v=t.radius;let g=!1;for(let f=0;f!==w.length;f++){const A=w[f],b=fi;o.vmult(A,b),s.vadd(b,b);const E=ui;if(b.vsub(n,E),E.lengthSquared()<v*v){if(u)return!0;g=!0;const _=this.createContactEquation(r,c,t,e,l,d);_.ri.copy(E),_.ri.normalize(),_.ni.copy(_.ri),_.ri.scale(v,_.ri),b.vsub(s,_.rj),_.ri.vadd(n,_.ri),_.ri.vsub(r.position,_.ri),_.rj.vadd(s,_.rj),_.rj.vsub(c.position,_.rj),this.result.push(_),this.createFrictionEquationsFromContact(_,this.frictionResult);return}}for(let f=0,A=m.length;f!==A&&g===!1;f++){const b=p[f],E=m[f],_=pi;o.vmult(b,_);const M=mi;o.vmult(w[E[0]],M),M.vadd(s,M);const R=vi;_.scale(-v,R),n.vadd(R,R);const O=yi;R.vsub(M,O);const N=O.dot(_),P=wi;if(n.vsub(M,P),N<0&&P.dot(_)>0){const I=[];for(let z=0,S=E.length;z!==S;z++){const T=h.get();o.vmult(w[E[z]],T),s.vadd(T,T),I.push(T)}if(ti(I,_,n)){if(u)return!0;g=!0;const z=this.createContactEquation(r,c,t,e,l,d);_.scale(-v,z.ri),_.negate(z.ni);const S=h.get();_.scale(-N,S);const T=h.get();_.scale(-v,T),n.vsub(s,z.rj),z.rj.vadd(T,z.rj),z.rj.vadd(S,z.rj),z.rj.vadd(s,z.rj),z.rj.vsub(c.position,z.rj),z.ri.vadd(n,z.ri),z.ri.vsub(r.position,z.ri),h.release(S),h.release(T),this.result.push(z),this.createFrictionEquationsFromContact(z,this.frictionResult);for(let C=0,W=I.length;C!==W;C++)h.release(I[C]);return}else for(let z=0;z!==E.length;z++){const S=h.get(),T=h.get();o.vmult(w[E[(z+1)%E.length]],S),o.vmult(w[E[(z+2)%E.length]],T),s.vadd(S,S),s.vadd(T,T);const C=hi;T.vsub(S,C);const W=di;C.unit(W);const q=h.get(),V=h.get();n.vsub(S,V);const H=V.dot(W);W.scale(H,q),q.vadd(S,q);const j=h.get();if(q.vsub(n,j),H>0&&H*H<C.lengthSquared()&&j.lengthSquared()<v*v){if(u)return!0;const L=this.createContactEquation(r,c,t,e,l,d);q.vsub(s,L.rj),q.vsub(n,L.ni),L.ni.normalize(),L.ni.scale(v,L.ri),L.rj.vadd(s,L.rj),L.rj.vsub(c.position,L.rj),L.ri.vadd(n,L.ri),L.ri.vsub(r.position,L.ri),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult);for(let K=0,st=I.length;K!==st;K++)h.release(I[K]);h.release(S),h.release(T),h.release(q),h.release(j),h.release(V);return}h.release(S),h.release(T),h.release(q),h.release(j),h.release(V)}for(let z=0,S=I.length;z!==S;z++)h.release(I[z])}}}planeConvex(t,e,n,s,i,o,r,c,l,d,u){const h=xi,p=gi;p.set(0,0,1),i.vmult(p,p);let m=0;const w=bi;for(let v=0;v!==e.vertices.length;v++)if(h.copy(e.vertices[v]),o.vmult(h,h),s.vadd(h,h),h.vsub(n,w),p.dot(w)<=0){if(u)return!0;const f=this.createContactEquation(r,c,t,e,l,d),A=Ei;p.scale(p.dot(w),A),h.vsub(A,A),A.vsub(n,f.ri),f.ni.copy(p),h.vsub(s,f.rj),f.ri.vadd(n,f.ri),f.ri.vsub(r.position,f.ri),f.rj.vadd(s,f.rj),f.rj.vsub(c.position,f.rj),this.result.push(f),m++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(f,this.frictionResult)}this.enableFrictionReduction&&m&&this.createFrictionFromAverage(m)}boxConvex(t,e,n,s,i,o,r,c,l,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}sphereHeightfield(t,e,n,s,i,o,r,c,l,d,u){const h=e.data,p=t.radius,m=e.elementSize,w=Li,v=Ii;D.pointToLocalFrame(s,o,n,v);let g=Math.floor((v.x-p)/m)-1,f=Math.ceil((v.x+p)/m)+1,A=Math.floor((v.y-p)/m)-1,b=Math.ceil((v.y+p)/m)+1;if(f<0||b<0||g>h.length||A>h[0].length)return;g<0&&(g=0),f<0&&(f=0),A<0&&(A=0),b<0&&(b=0),g>=h.length&&(g=h.length-1),f>=h.length&&(f=h.length-1),b>=h[0].length&&(b=h[0].length-1),A>=h[0].length&&(A=h[0].length-1);const E=[];e.getRectMinMax(g,A,f,b,E);const _=E[0],M=E[1];if(v.z-p>M||v.z+p<_)return;const R=this.result;for(let O=g;O<f;O++)for(let N=A;N<b;N++){const P=R.length;let I=!1;if(e.getConvexTrianglePillar(O,N,!1),D.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(I=this.sphereConvex(t,e.pillarConvex,n,w,i,o,r,c,t,e,u)),u&&I||(e.getConvexTrianglePillar(O,N,!0),D.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(I=this.sphereConvex(t,e.pillarConvex,n,w,i,o,r,c,t,e,u)),u&&I))return!0;if(R.length-P>2)return}}boxHeightfield(t,e,n,s,i,o,r,c,l,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}convexHeightfield(t,e,n,s,i,o,r,c,l,d,u){const h=e.data,p=e.elementSize,m=t.boundingSphereRadius,w=Pi,v=Ni,g=Ri;D.pointToLocalFrame(s,o,n,g);let f=Math.floor((g.x-m)/p)-1,A=Math.ceil((g.x+m)/p)+1,b=Math.floor((g.y-m)/p)-1,E=Math.ceil((g.y+m)/p)+1;if(A<0||E<0||f>h.length||b>h[0].length)return;f<0&&(f=0),A<0&&(A=0),b<0&&(b=0),E<0&&(E=0),f>=h.length&&(f=h.length-1),A>=h.length&&(A=h.length-1),E>=h[0].length&&(E=h[0].length-1),b>=h[0].length&&(b=h[0].length-1);const _=[];e.getRectMinMax(f,b,A,E,_);const M=_[0],R=_[1];if(!(g.z-m>R||g.z+m<M))for(let O=f;O<A;O++)for(let N=b;N<E;N++){let P=!1;if(e.getConvexTrianglePillar(O,N,!1),D.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(P=this.convexConvex(t,e.pillarConvex,n,w,i,o,r,c,null,null,u,v,null)),u&&P||(e.getConvexTrianglePillar(O,N,!0),D.pointToWorldFrame(s,o,e.pillarOffset,w),n.distanceTo(w)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(P=this.convexConvex(t,e.pillarConvex,n,w,i,o,r,c,null,null,u,v,null)),u&&P))return!0}}sphereParticle(t,e,n,s,i,o,r,c,l,d,u){const h=Ti;if(h.set(0,0,1),s.vsub(n,h),h.lengthSquared()<=t.radius*t.radius){if(u)return!0;const m=this.createContactEquation(c,r,e,t,l,d);h.normalize(),m.rj.copy(h),m.rj.scale(t.radius,m.rj),m.ni.copy(h),m.ni.negate(m.ni),m.ri.set(0,0,0),this.result.push(m),this.createFrictionEquationsFromContact(m,this.frictionResult)}}planeParticle(t,e,n,s,i,o,r,c,l,d,u){const h=Ci;h.set(0,0,1),r.quaternion.vmult(h,h);const p=_i;if(s.vsub(r.position,p),h.dot(p)<=0){if(u)return!0;const w=this.createContactEquation(c,r,e,t,l,d);w.ni.copy(h),w.ni.negate(w.ni),w.ri.set(0,0,0);const v=Mi;h.scale(h.dot(s),v),s.vsub(v,v),w.rj.copy(v),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult)}}boxParticle(t,e,n,s,i,o,r,c,l,d,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,n,s,i,o,r,c,t,e,u)}convexParticle(t,e,n,s,i,o,r,c,l,d,u){let h=-1;const p=Fi,m=Bi;let w=null;const v=Si;if(v.copy(s),v.vsub(n,v),i.conjugate(We),We.vmult(v,v),t.pointIsInside(v)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(n,i),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(i);for(let g=0,f=t.faces.length;g!==f;g++){const A=[t.worldVertices[t.faces[g][0]]],b=t.worldFaceNormals[g];s.vsub(A[0],De);const E=-b.dot(De);if(w===null||Math.abs(E)<Math.abs(w)){if(u)return!0;w=E,h=g,p.copy(b)}}if(h!==-1){const g=this.createContactEquation(c,r,e,t,l,d);p.scale(w,m),m.vadd(s,m),m.vsub(n,m),g.rj.copy(m),p.negate(g.ni),g.ri.set(0,0,0);const f=g.ri,A=g.rj;f.vadd(s,f),f.vsub(c.position,f),A.vadd(n,A),A.vsub(r.position,A),this.result.push(g),this.createFrictionEquationsFromContact(g,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,n,s,i,o,r,c,l,d,u){return this.convexHeightfield(e,t,s,n,o,i,c,r,l,d,u)}particleCylinder(t,e,n,s,i,o,r,c,l,d,u){return this.convexParticle(e,t,s,n,o,i,c,r,l,d,u)}sphereTrimesh(t,e,n,s,i,o,r,c,l,d,u){const h=Ws,p=Ds,m=ks,w=js,v=Hs,g=Us,f=$s,A=Vs,b=qs,E=Zs;D.pointToLocalFrame(s,o,n,v);const _=t.radius;f.lowerBound.set(v.x-_,v.y-_,v.z-_),f.upperBound.set(v.x+_,v.y+_,v.z+_),e.getTrianglesInAABB(f,E);const M=Os,R=t.radius*t.radius;for(let z=0;z<E.length;z++)for(let S=0;S<3;S++)if(e.getVertex(e.indices[E[z]*3+S],M),M.vsub(v,b),b.lengthSquared()<=R){if(A.copy(M),D.pointToWorldFrame(s,o,A,M),M.vsub(n,b),u)return!0;let T=this.createContactEquation(r,c,t,e,l,d);T.ni.copy(b),T.ni.normalize(),T.ri.copy(T.ni),T.ri.scale(t.radius,T.ri),T.ri.vadd(n,T.ri),T.ri.vsub(r.position,T.ri),T.rj.copy(M),T.rj.vsub(c.position,T.rj),this.result.push(T),this.createFrictionEquationsFromContact(T,this.frictionResult)}for(let z=0;z<E.length;z++)for(let S=0;S<3;S++){e.getVertex(e.indices[E[z]*3+S],h),e.getVertex(e.indices[E[z]*3+(S+1)%3],p),p.vsub(h,m),v.vsub(p,g);const T=g.dot(m);v.vsub(h,g);let C=g.dot(m);if(C>0&&T<0&&(v.vsub(h,g),w.copy(m),w.normalize(),C=g.dot(w),w.scale(C,g),g.vadd(h,g),g.distanceTo(v)<t.radius)){if(u)return!0;const q=this.createContactEquation(r,c,t,e,l,d);g.vsub(v,q.ni),q.ni.normalize(),q.ni.scale(t.radius,q.ri),q.ri.vadd(n,q.ri),q.ri.vsub(r.position,q.ri),D.pointToWorldFrame(s,o,g,g),g.vsub(c.position,q.rj),D.vectorToWorldFrame(o,q.ni,q.ni),D.vectorToWorldFrame(o,q.ri,q.ri),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}}const O=Gs,N=Ys,P=Xs,I=Ls;for(let z=0,S=E.length;z!==S;z++){e.getTriangleVertices(E[z],O,N,P),e.getNormal(E[z],I),v.vsub(O,g);let T=g.dot(I);if(I.scale(T,g),v.vsub(g,g),T=g.distanceTo(v),U.pointInTriangle(g,O,N,P)&&T<t.radius){if(u)return!0;let C=this.createContactEquation(r,c,t,e,l,d);g.vsub(v,C.ni),C.ni.normalize(),C.ni.scale(t.radius,C.ri),C.ri.vadd(n,C.ri),C.ri.vsub(r.position,C.ri),D.pointToWorldFrame(s,o,g,g),g.vsub(c.position,C.rj),D.vectorToWorldFrame(o,C.ni,C.ni),D.vectorToWorldFrame(o,C.ri,C.ri),this.result.push(C),this.createFrictionEquationsFromContact(C,this.frictionResult)}}E.length=0}planeTrimesh(t,e,n,s,i,o,r,c,l,d,u){const h=new a,p=Ps;p.set(0,0,1),i.vmult(p,p);for(let m=0;m<e.vertices.length/3;m++){e.getVertex(m,h);const w=new a;w.copy(h),D.pointToWorldFrame(s,o,w,h);const v=Ns;if(h.vsub(n,v),p.dot(v)<=0){if(u)return!0;const f=this.createContactEquation(r,c,t,e,l,d);f.ni.copy(p);const A=Is;p.scale(v.dot(p),A),h.vsub(A,A),f.ri.copy(A),f.ri.vsub(r.position,f.ri),f.rj.copy(h),f.rj.vsub(c.position,f.rj),this.result.push(f),this.createFrictionEquationsFromContact(f,this.frictionResult)}}}}const mt=new a,bt=new a,Et=new a,Ss=new a,Fs=new a,Bs=new G,Rs=new G,Ps=new a,Ns=new a,Is=new a,Ls=new a,qs=new a;new a;const Os=new a,Vs=new a,Ws=new a,Ds=new a,ks=new a,js=new a,Hs=new a,Us=new a,Gs=new a,Ys=new a,Xs=new a,$s=new tt,Zs=[],Ut=new a,Ve=new a,Ks=new a,Qs=new a,Js=new a;function ti(x,t,e){let n=null;const s=x.length;for(let i=0;i!==s;i++){const o=x[i],r=Ks;x[(i+1)%s].vsub(o,r);const c=Qs;r.cross(t,c);const l=Js;e.vsub(o,l);const d=c.dot(l);if(n===null||d>0&&n===!0||d<=0&&n===!1){n===null&&(n=d>0);continue}else return!1}return!0}const Gt=new a,ei=new a,ni=new a,si=new a,ii=[new a,new a,new a,new a,new a,new a],oi=new a,ri=new a,ci=new a,ai=new a,li=new a,hi=new a,di=new a,ui=new a,fi=new a,pi=new a,mi=new a,vi=new a,yi=new a,wi=new a;new a;new a;const xi=new a,gi=new a,bi=new a,Ei=new a,Ai=new a,zi=new a,Ci=new a,_i=new a,Mi=new a,Ti=new a,We=new G,Si=new a;new a;const Fi=new a,De=new a,Bi=new a,Ri=new a,Pi=new a,Ni=[0],Ii=new a,Li=new a;class ke{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){const n=e;e=t,t=n}return t<<16|e}set(t,e){const n=this.getKey(t,e),s=this.current;let i=0;for(;n>s[i];)i++;if(n!==s[i]){for(let o=s.length-1;o>=i;o--)s[o+1]=s[o];s[i]=n}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const n=this.current,s=this.previous,i=n.length,o=s.length;let r=0;for(let c=0;c<i;c++){let l=!1;const d=n[c];for(;d>s[r];)r++;l=d===s[r],l||je(t,d)}r=0;for(let c=0;c<o;c++){let l=!1;const d=s[c];for(;d>n[r];)r++;l=n[r]===d,l||je(e,d)}}}function je(x,t){x.push((t&4294901760)>>16,t&65535)}const oe=(x,t)=>x<t?`${x}-${t}`:`${t}-${x}`;class qi{constructor(){this.data={keys:[]}}get(t,e){const n=oe(t,e);return this.data[n]}set(t,e,n){const s=oe(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=n}delete(t,e){const n=oe(t,e),s=this.data.keys.indexOf(n);s!==-1&&this.data.keys.splice(s,1),delete this.data[n]}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const n=e.pop();delete t[n]}}}class Oi extends Qe{constructor(t){t===void 0&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new a,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new a,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=t.broadphase!==void 0?t.broadphase:new Un,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new Es,this.constraints=[],this.narrowphase=new Ts(this),this.collisionMatrix=new Te,this.collisionMatrixPrevious=new Te,this.bodyOverlapKeeper=new ke,this.shapeOverlapKeeper=new ke,this.contactmaterials=[],this.contactMaterialTable=new qi,this.defaultMaterial=new St("default"),this.defaultContactMaterial=new Tt(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,n){n instanceof Kt?this.raycastClosest(t,e,{skipBackfaces:!0},n):this.raycastAll(t,e,{skipBackfaces:!0},n)}raycastAll(t,e,n,s){return n===void 0&&(n={}),n.mode=U.ALL,n.from=t,n.to=e,n.callback=s,re.intersectWorld(this,n)}raycastAny(t,e,n,s){return n===void 0&&(n={}),n.mode=U.ANY,n.from=t,n.to=e,n.result=s,re.intersectWorld(this,n)}raycastClosest(t,e,n,s){return n===void 0&&(n={}),n.mode=U.CLOSEST,n.from=t,n.to=e,n.result=s,re.intersectWorld(this,n)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,n=this.bodies,s=n.indexOf(t);if(s!==-1){n.splice(s,1);for(let i=0;i!==n.length;i++)n[i].index=i;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let n=0;n<e.length;n++){const s=e[n].shapes;for(let i=0;i<s.length;i++){const o=s[i];if(o.id===t)return o}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){const e=this.contactmaterials.indexOf(t);e!==-1&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){t===void 0&&(t=1/60),e===void 0&&(e=10);const n=X.now()/1e3;if(!this.lastCallTime)this.step(t,void 0,e);else{const s=n-this.lastCallTime;this.step(t,s,e)}this.lastCallTime=n}step(t,e,n){if(n===void 0&&(n=10),e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const s=X.now();let i=0;for(;this.accumulator>=t&&i<n&&(this.internalStep(t),this.accumulator-=t,i++,!(X.now()-s>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const c=this.bodies[r];c.previousPosition.lerp(c.position,o,c.interpolatedPosition),c.previousQuaternion.slerp(c.quaternion,o,c.interpolatedQuaternion),c.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,n=ji,s=Hi,i=this.bodies.length,o=this.bodies,r=this.solver,c=this.gravity,l=this.doProfiling,d=this.profile,u=F.DYNAMIC;let h=-1/0;const p=this.constraints,m=ki;c.length();const w=c.x,v=c.y,g=c.z;let f=0;for(l&&(h=X.now()),f=0;f!==i;f++){const z=o[f];if(z.type===u){const S=z.force,T=z.mass;S.x+=T*w,S.y+=T*v,S.z+=T*g}}for(let z=0,S=this.subsystems.length;z!==S;z++)this.subsystems[z].update();l&&(h=X.now()),n.length=0,s.length=0,this.broadphase.collisionPairs(this,n,s),l&&(d.broadphase=X.now()-h);let A=p.length;for(f=0;f!==A;f++){const z=p[f];if(!z.collideConnected)for(let S=n.length-1;S>=0;S-=1)(z.bodyA===n[S]&&z.bodyB===s[S]||z.bodyB===n[S]&&z.bodyA===s[S])&&(n.splice(S,1),s.splice(S,1))}this.collisionMatrixTick(),l&&(h=X.now());const b=Di,E=e.length;for(f=0;f!==E;f++)b.push(e[f]);e.length=0;const _=this.frictionEquations.length;for(f=0;f!==_;f++)m.push(this.frictionEquations[f]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(n,s,this,e,b,this.frictionEquations,m),l&&(d.narrowphase=X.now()-h),l&&(h=X.now()),f=0;f<this.frictionEquations.length;f++)r.addEquation(this.frictionEquations[f]);const M=e.length;for(let z=0;z!==M;z++){const S=e[z],T=S.bi,C=S.bj,W=S.si,q=S.sj;let V;if(T.material&&C.material?V=this.getContactMaterial(T.material,C.material)||this.defaultContactMaterial:V=this.defaultContactMaterial,V.friction,T.material&&C.material&&(T.material.friction>=0&&C.material.friction>=0&&T.material.friction*C.material.friction,T.material.restitution>=0&&C.material.restitution>=0&&(S.restitution=T.material.restitution*C.material.restitution)),r.addEquation(S),T.allowSleep&&T.type===F.DYNAMIC&&T.sleepState===F.SLEEPING&&C.sleepState===F.AWAKE&&C.type!==F.STATIC){const H=C.velocity.lengthSquared()+C.angularVelocity.lengthSquared(),j=C.sleepSpeedLimit**2;H>=j*2&&(T.wakeUpAfterNarrowphase=!0)}if(C.allowSleep&&C.type===F.DYNAMIC&&C.sleepState===F.SLEEPING&&T.sleepState===F.AWAKE&&T.type!==F.STATIC){const H=T.velocity.lengthSquared()+T.angularVelocity.lengthSquared(),j=T.sleepSpeedLimit**2;H>=j*2&&(C.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(T,C,!0),this.collisionMatrixPrevious.get(T,C)||(Pt.body=C,Pt.contact=S,T.dispatchEvent(Pt),Pt.body=T,C.dispatchEvent(Pt)),this.bodyOverlapKeeper.set(T.id,C.id),this.shapeOverlapKeeper.set(W.id,q.id)}for(this.emitContactEvents(),l&&(d.makeContactConstraints=X.now()-h,h=X.now()),f=0;f!==i;f++){const z=o[f];z.wakeUpAfterNarrowphase&&(z.wakeUp(),z.wakeUpAfterNarrowphase=!1)}for(A=p.length,f=0;f!==A;f++){const z=p[f];z.update();for(let S=0,T=z.equations.length;S!==T;S++){const C=z.equations[S];r.addEquation(C)}}r.solve(t,this),l&&(d.solve=X.now()-h),r.removeAllEquations();const R=Math.pow;for(f=0;f!==i;f++){const z=o[f];if(z.type&u){const S=R(1-z.linearDamping,t),T=z.velocity;T.scale(S,T);const C=z.angularVelocity;if(C){const W=R(1-z.angularDamping,t);C.scale(W,C)}}}this.dispatchEvent(Wi),l&&(h=X.now());const N=this.stepnumber%(this.quatNormalizeSkip+1)===0,P=this.quatNormalizeFast;for(f=0;f!==i;f++)o[f].integrate(t,N,P);this.clearForces(),this.broadphase.dirty=!0,l&&(d.integrate=X.now()-h),this.stepnumber+=1,this.dispatchEvent(Vi);let I=!0;if(this.allowSleep)for(I=!1,f=0;f!==i;f++){const z=o[f];z.sleepTick(this.time),z.sleepState!==F.SLEEPING&&(I=!0)}this.hasActiveBodies=I}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(at,lt),t){for(let i=0,o=at.length;i<o;i+=2)Nt.bodyA=this.getBodyById(at[i]),Nt.bodyB=this.getBodyById(at[i+1]),this.dispatchEvent(Nt);Nt.bodyA=Nt.bodyB=null}if(e){for(let i=0,o=lt.length;i<o;i+=2)It.bodyA=this.getBodyById(lt[i]),It.bodyB=this.getBodyById(lt[i+1]),this.dispatchEvent(It);It.bodyA=It.bodyB=null}at.length=lt.length=0;const n=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((n||s)&&this.shapeOverlapKeeper.getDiff(at,lt),n){for(let i=0,o=at.length;i<o;i+=2){const r=this.getShapeById(at[i]),c=this.getShapeById(at[i+1]);ht.shapeA=r,ht.shapeB=c,r&&(ht.bodyA=r.body),c&&(ht.bodyB=c.body),this.dispatchEvent(ht)}ht.bodyA=ht.bodyB=ht.shapeA=ht.shapeB=null}if(s){for(let i=0,o=lt.length;i<o;i+=2){const r=this.getShapeById(lt[i]),c=this.getShapeById(lt[i+1]);dt.shapeA=r,dt.shapeB=c,r&&(dt.bodyA=r.body),c&&(dt.bodyB=c.body),this.dispatchEvent(dt)}dt.bodyA=dt.bodyB=dt.shapeA=dt.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let n=0;n!==e;n++){const s=t[n];s.force,s.torque,s.force.set(0,0,0),s.torque.set(0,0,0)}}}new tt;const re=new U,X=globalThis.performance||{};if(!X.now){let x=Date.now();X.timing&&X.timing.navigationStart&&(x=X.timing.navigationStart),X.now=()=>Date.now()-x}new a;const Vi={type:"postStep"},Wi={type:"preStep"},Pt={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},Di=[],ki=[],ji=[],Hi=[],at=[],lt=[],Nt={type:"beginContact",bodyA:null,bodyB:null},It={type:"endContact",bodyA:null,bodyB:null},ht={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},dt={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};vn.setupViewport();fe.init({keyboardFallback:!0});const Z=document.getElementById("glcanvas"),y=Z.getContext("webgl2",{antialias:!0,alpha:!0});y||console.error("WebGL2 not supported");function He(x){const t=x[0],e=x[1],n=x[2],s=x[3],i=t+t,o=e+e,r=n+n,c=t*i,l=t*o,d=t*r,u=e*o,h=e*r,p=n*r,m=s*i,w=s*o,v=s*r;return new Float32Array([1-(u+p),l-v,d+w,0,l+v,1-(c+p),h-m,0,d-w,h+m,1-(c+u),0,0,0,0,1])}function Ui(x,t,e,n,s,i){const o=new Float32Array(16),r=1/(x-t),c=1/(e-n),l=1/(s-i);return o[0]=-2*r,o[5]=-2*c,o[10]=2*l,o[12]=(x+t)*r,o[13]=(n+e)*c,o[14]=(i+s)*l,o[15]=1,o}function Gi(x,t,e){const[n,s,i]=x,[o,r,c]=t,[l,d,u]=e;let h=n-o,p=s-r,m=i-c,w=Math.hypot(h,p,m)||1;h/=w,p/=w,m/=w;let v=d*m-u*p,g=u*h-l*m,f=l*p-d*h,A=Math.hypot(v,g,f)||1;v/=A,g/=A,f/=A;let b=p*f-m*g,E=m*v-h*f,_=h*g-p*v;const M=new Float32Array(16);return M[0]=v,M[1]=b,M[2]=h,M[3]=0,M[4]=g,M[5]=E,M[6]=p,M[7]=0,M[8]=f,M[9]=_,M[10]=m,M[11]=0,M[12]=-(v*n+g*s+f*i),M[13]=-(b*n+E*s+_*i),M[14]=-(h*n+p*s+m*i),M[15]=1,M}function Yi(){const x=Math.min(window.devicePixelRatio||1,2),t=Math.floor(Z.clientWidth*x)||window.innerWidth,e=Math.floor(Z.clientHeight*x)||window.innerHeight;(Z.width!==t||Z.height!==e)&&(Z.width=t,Z.height=e),y.viewport(0,0,Z.width,Z.height)}function Xi(){Z.style.width||(Z.style.width="100vw"),Z.style.height||(Z.style.height="100vh"),Z.style.display="block"}Xi();function $i(x={}){const e=x.resolution||20,n=x.pipRadius||.18,s=x.pipDepth||.25,i=x.pipSpread||.6,o=[0,0],r=[[-i,-i],[-i,i],[i,-i],[i,i]],c=[[-i,0],[i,0]];function l(f){switch(f){case 1:return[o];case 2:return[r[0],r[3]];case 3:return[r[0],o,r[3]];case 4:return[r[0],r[1],r[2],r[3]];case 5:return[r[0],r[1],o,r[2],r[3]];case 6:return[r[0],r[1],c[0],c[1],r[2],r[3]];default:return[]}}const d=[{n:[1,0,0],u:[0,0,-1],v:[0,1,0],val:1},{n:[-1,0,0],u:[0,0,1],v:[0,1,0],val:6},{n:[0,1,0],u:[1,0,0],v:[0,0,1],val:2},{n:[0,-1,0],u:[1,0,0],v:[0,0,-1],val:5},{n:[0,0,1],u:[1,0,0],v:[0,1,0],val:3},{n:[0,0,-1],u:[-1,0,0],v:[0,1,0],val:4}],u=[],h=[],p=[];let m=0;function w(f){const A=Math.hypot(f[0],f[1],f[2])||1;return[f[0]/A,f[1]/A,f[2]/A]}for(let f=0;f<d.length;f++){const A=d[f],b=A.n,E=A.u,_=A.v,M=[b[0]*1,b[1]*1,b[2]*1],R=l(A.val),O=new Array((e+1)*(e+1)),N=p.length;for(let P=0;P<=e;P++)for(let I=0;I<=e;I++){const z=I/e*2-1,S=P/e*2-1;let T=M[0]+E[0]*z*1+_[0]*S*1,C=M[1]+E[1]*z*1+_[1]*S*1,W=M[2]+E[2]*z*1+_[2]*S*1,q=0;for(let V=0;V<R.length;V++){const H=R[V][0],j=R[V][1],L=z-H,K=S-j,st=Math.hypot(L,K),it=n,ut=n*.6;let ft=0;if(st<it){const xt=Math.min(1,Math.max(0,(it-st)/(it-ut)));ft=xt*xt*(3-2*xt);const Dt=s*(.3+.7*ft);Dt>q&&(q=Dt)}}T-=b[0]*q,C-=b[1]*q,W-=b[2]*q,u.push(T,C,W),h.push(b[0],b[1],b[2]),O[P*(e+1)+I]=m+P*(e+1)+I}for(let P=0;P<e;P++)for(let I=0;I<e;I++){const z=O[P*(e+1)+I],S=O[P*(e+1)+I+1],T=O[(P+1)*(e+1)+I+1],C=O[(P+1)*(e+1)+I];p.push(z,S,T,z,T,C)}if(p.length>N){const P=p[N+0],I=p[N+1],z=p[N+2],S=u[3*P],T=u[3*P+1],C=u[3*P+2],W=u[3*I],q=u[3*I+1],V=u[3*I+2],H=u[3*z],j=u[3*z+1],L=u[3*z+2],K=W-S,st=q-T,it=V-C,ut=H-S,ft=j-T,xt=L-C,Dt=st*xt-it*ft,un=it*ut-K*xt,fn=K*ft-st*ut;if(Dt*b[0]+un*b[1]+fn*b[2]<0)for(let gt=N;gt<p.length;gt+=3){const pn=p[gt+1];p[gt+1]=p[gt+2],p[gt+2]=pn}}m+=(e+1)*(e+1)}const v=new Array(u.length/3).fill(0).map(()=>[0,0,0]);for(let f=0;f<p.length;f+=3){const A=p[f],b=p[f+1],E=p[f+2],_=u[3*A],M=u[3*A+1],R=u[3*A+2],O=u[3*b],N=u[3*b+1],P=u[3*b+2],I=u[3*E],z=u[3*E+1],S=u[3*E+2],T=O-_,C=N-M,W=P-R,q=I-_,V=z-M,H=S-R,j=C*H-W*V,L=W*q-T*H,K=T*V-C*q;v[A][0]+=j,v[A][1]+=L,v[A][2]+=K,v[b][0]+=j,v[b][1]+=L,v[b][2]+=K,v[E][0]+=j,v[E][1]+=L,v[E][2]+=K}const g=new Float32Array(h.length);for(let f=0;f<v.length;f++){const A=w(v[f]);g[3*f]=A[0],g[3*f+1]=A[1],g[3*f+2]=A[2]}return{positions:new Float32Array(u),normals:g,indices:new Uint32Array(p)}}const Ot=$i({resolution:20,pipRadius:.18,pipDepth:.28,pipSpread:.6}),Zi=`#version 300 es
precision highp float;
layout(location=0) in vec3 a_position;
layout(location=1) in vec3 a_normal;
uniform mat4 u_mvp;
uniform mat4 u_model;
uniform mat4 u_lightVP;
out vec3 v_nrm_world;
out vec4 v_pos_world;
void main(){
  mat3 nm = transpose(inverse(mat3(u_model)));
  vec3 n = nm * a_normal;
  v_nrm_world = normalize(n);
  v_pos_world = u_model * vec4(a_position, 1.0);
  gl_Position = u_mvp * v_pos_world;
}`,Ki=`#version 300 es
precision highp float;
precision highp sampler2DShadow;
in vec3 v_nrm_world;
in vec4 v_pos_world;
out vec4 outColor;
uniform mat4 u_lightVP;
uniform highp sampler2DShadow u_shadowMap;
uniform vec3 u_baseColor;
uniform vec3 u_lightDir;
const vec3 LIGHT_COLOR = vec3(1.0);
const vec3 AMBIENT = vec3(0.18);
void main(){
  vec3 N = normalize(v_nrm_world);
  vec3 L = normalize(-u_lightDir);
  float ndl = max(0.0, dot(N, L));
  // Shadow mapping
  vec4 posLight = u_lightVP * v_pos_world;
  vec3 sc = posLight.xyz / max(0.0001, posLight.w);
  sc = sc * 0.5 + 0.5;
  float shadow = 1.0;
  if (sc.x > 0.0 && sc.x < 1.0 && sc.y > 0.0 && sc.y < 1.0 && sc.z > 0.0 && sc.z < 1.0) {
    float bias = max(0.0025, 0.006 * (1.0 - ndl));
    shadow = texture(u_shadowMap, vec3(sc.xy, sc.z - bias));
  }
  float shadowTerm = mix(0.6, 1.0, shadow);
  vec3 diffuse = u_baseColor * LIGHT_COLOR * ndl * shadowTerm;
  vec3 color = diffuse + AMBIENT * u_baseColor;
  outColor = vec4(color, 1.0);
}`,Qi=`#version 300 es
precision highp float;
layout(location=0) in vec3 a_position;
uniform mat4 u_vp;
void main(){ gl_Position = u_vp * vec4(a_position, 1.0); }`,Ji=`#version 300 es
precision highp float;
uniform vec4 u_color;
out vec4 outColor;
void main(){ outColor = u_color; }`;function Ue(x,t,e){const n=x.createShader(t);return x.shaderSource(n,e),x.compileShader(n),x.getShaderParameter(n,x.COMPILE_STATUS)?n:(console.error(x.getShaderInfoLog(n)||"shader error"),x.deleteShader(n),null)}function ye(x,t,e){const n=Ue(x,x.VERTEX_SHADER,t),s=Ue(x,x.FRAGMENT_SHADER,e),i=x.createProgram();return x.attachShader(i,n),x.attachShader(i,s),x.linkProgram(i),x.getProgramParameter(i,x.LINK_STATUS)?i:(console.error(x.getProgramInfoLog(i)||"link error"),x.deleteProgram(i),null)}const wt=ye(y,Zi,Ki),ae=y.createVertexArray();y.bindVertexArray(ae);const to=y.createBuffer();y.bindBuffer(y.ARRAY_BUFFER,to);y.bufferData(y.ARRAY_BUFFER,Ot.positions,y.STATIC_DRAW);y.enableVertexAttribArray(0);y.vertexAttribPointer(0,3,y.FLOAT,!1,0,0);const eo=y.createBuffer();y.bindBuffer(y.ARRAY_BUFFER,eo);y.bufferData(y.ARRAY_BUFFER,Ot.normals,y.STATIC_DRAW);y.enableVertexAttribArray(1);y.vertexAttribPointer(1,3,y.FLOAT,!1,0,0);const no=y.createBuffer();y.bindBuffer(y.ELEMENT_ARRAY_BUFFER,no);y.bufferData(y.ELEMENT_ARRAY_BUFFER,Ot.indices,y.STATIC_DRAW);const so=y.getUniformLocation(wt,"u_mvp"),Ge=y.getUniformLocation(wt,"u_model"),io=y.getUniformLocation(wt,"u_lightVP"),oo=y.getUniformLocation(wt,"u_shadowMap"),Ye=y.getUniformLocation(wt,"u_baseColor"),ro=y.getUniformLocation(wt,"u_lightDir"),an=ye(y,Qi,Ji);y.getUniformLocation(an,"u_vp");y.getUniformLocation(an,"u_color");function co(x){const t=x,e=[],n=[[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t],[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t]],s=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];for(const[i,o]of s)e.push(...n[i],...n[o]);return new Float32Array(e)}const $=2,ao=co($),lo=y.createVertexArray();y.bindVertexArray(lo);const ho=y.createBuffer();y.bindBuffer(y.ARRAY_BUFFER,ho);y.bufferData(y.ARRAY_BUFFER,ao,y.STATIC_DRAW);y.enableVertexAttribArray(0);y.vertexAttribPointer(0,3,y.FLOAT,!1,0,0);function uo(x){const t=x,e=[t,-t,-t,t,t,-t,t,t,t,t,-t,t,-t,-t,t,-t,t,t,-t,t,-t,-t,-t,-t,-t,-t,t,-t,t,t,t,t,t,t,-t,t,t,-t,-t,t,t,-t,-t,t,-t,-t,-t,-t,-t,-t,-t,-t,-t,t,t,-t,t,t,-t,-t],n=[-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0],s=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19];return{positions:new Float32Array(e),normals:new Float32Array(n),indices:new Uint16Array(s)}}const we=uo(2),le=y.createVertexArray();y.bindVertexArray(le);const fo=y.createBuffer();y.bindBuffer(y.ARRAY_BUFFER,fo);y.bufferData(y.ARRAY_BUFFER,we.positions,y.STATIC_DRAW);y.enableVertexAttribArray(0);y.vertexAttribPointer(0,3,y.FLOAT,!1,0,0);const po=y.createBuffer();y.bindBuffer(y.ARRAY_BUFFER,po);y.bufferData(y.ARRAY_BUFFER,we.normals,y.STATIC_DRAW);y.enableVertexAttribArray(1);y.vertexAttribPointer(1,3,y.FLOAT,!1,0,0);const mo=y.createBuffer();y.bindBuffer(y.ELEMENT_ARRAY_BUFFER,mo);y.bufferData(y.ELEMENT_ARRAY_BUFFER,we.indices,y.STATIC_DRAW);const Qt=1024,ln=y.createFramebuffer();y.bindFramebuffer(y.FRAMEBUFFER,ln);const xe=y.createTexture();y.bindTexture(y.TEXTURE_2D,xe);y.texImage2D(y.TEXTURE_2D,0,y.DEPTH_COMPONENT24,Qt,Qt,0,y.DEPTH_COMPONENT,y.UNSIGNED_INT,null);y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MIN_FILTER,y.NEAREST);y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MAG_FILTER,y.NEAREST);y.texParameteri(y.TEXTURE_2D,y.TEXTURE_WRAP_S,y.CLAMP_TO_EDGE);y.texParameteri(y.TEXTURE_2D,y.TEXTURE_WRAP_T,y.CLAMP_TO_EDGE);try{y.texParameteri(y.TEXTURE_2D,y.TEXTURE_COMPARE_MODE,y.COMPARE_REF_TO_TEXTURE),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_COMPARE_FUNC,y.LEQUAL)}catch{}y.framebufferTexture2D(y.FRAMEBUFFER,y.DEPTH_ATTACHMENT,y.TEXTURE_2D,xe,0);y.drawBuffers([y.NONE]);y.readBuffer(y.NONE);y.bindFramebuffer(y.FRAMEBUFFER,null);const vo=`#version 300 es
precision highp float;
layout(location=0) in vec3 a_position;
uniform mat4 u_lightVP;
uniform mat4 u_model;
void main(){ gl_Position = u_lightVP * u_model * vec4(a_position,1.0); }`,yo=`#version 300 es
precision highp float;
void main(){}
`,ge=ye(y,vo,yo),Xe=y.getUniformLocation(ge,"u_model"),wo=y.getUniformLocation(ge,"u_lightVP"),yt=.5*.75,Yt=.9;function be(x,t={}){const e=yt,n=new Vt(new a(yt,yt,yt)),s=new F({mass:1,shape:n,material:Jt,angularDamping:.2,linearDamping:.05});if(s.position.set(x[0],x[1],x[2]),t.initialVelocity){const i=t.initialVelocity;s.velocity.set(i[0],i[1],i[2])}else s.velocity.set((Math.random()-.5)*.5,Math.random()*.5,(Math.random()-.5)*.5);if(t.angularVelocity){const i=t.angularVelocity;s.angularVelocity.set(i[0],i[1],i[2])}else s.angularVelocity.set(0,0,0);return s.allowSleep=!0,s.sleepSpeedLimit=.25,s.sleepTimeLimit=.4,Q.addBody(s),{size:e,body:s}}let Y=[],$e=!1,qt=1;function Xt(x,t,e){return Math.max(t,Math.min(e,x))}let he=1.71,Mt=2.91,Ee=!1,de=0,ue=0;window.addEventListener("mousedown",x=>{x.shiftKey&&(Ee=!0,de=x.clientX,ue=x.clientY)});window.addEventListener("mousemove",x=>{if(!Ee)return;const t=(x.clientX-de)/window.innerWidth,e=(x.clientY-ue)/window.innerHeight;de=x.clientX,ue=x.clientY,he+=t*Math.PI*2,Mt+=-e*Math.PI;const n=.05;Mt=Math.max(n,Math.min(Math.PI-n,Mt))});window.addEventListener("mouseup",()=>{Ee=!1});let Ct=0,_t=0;function xo(){function x(s){const i=(s.beta||0)*Math.PI/180,o=(s.gamma||0)*Math.PI/180;Ct=Xt(i,-Math.PI/2,Math.PI/2),_t=Xt(o,-Math.PI/2,Math.PI/2)}try{const s=window.DeviceOrientationEvent;s&&s.requestPermission?document.body.addEventListener("click",async()=>{try{await s.requestPermission()==="granted"&&window.addEventListener("deviceorientation",x)}catch{}},{once:!0}):s&&window.addEventListener("deviceorientation",x)}catch{}let t=!1,e=0,n=0;window.addEventListener("mousedown",s=>{t=!0,e=s.clientX,n=s.clientY}),window.addEventListener("mousemove",s=>{if(!t)return;const i=(s.clientX-e)/window.innerWidth,o=(s.clientY-n)/window.innerHeight;e=s.clientX,n=s.clientY,_t+=i*Math.PI,Ct+=o*Math.PI,Ct=Xt(Ct,-Math.PI/2,Math.PI/2),_t=Xt(_t,-Math.PI/2,Math.PI/2)}),window.addEventListener("mouseup",()=>t=!1)}xo();let Ae=!1;const Zt=new Float32Array([0,-9.8,0]),ce=new Float32Array([0,-1,0]),At=new Float32Array([0,-1,0]);function go(){for(let x=0;x<Y.length;x++)try{Y[x].body.wakeUp()}catch{}}function bo(x,t,e){const n=x-At[0],s=t-At[1],i=e-At[2],o=Math.hypot(n,s,i),r=Math.hypot(x,t,e);(o>.05||r>.2)&&go(),At[0]=x,At[1]=t,At[2]=e}function $t(x=60){var t;try{const e=(t=window==null?void 0:window.creationSensors)==null?void 0:t.accelerometer;if(e&&typeof e.start=="function")return e.start(n=>{if(!n)return;const s=typeof n.tiltX=="number"?n.tiltX:typeof n.x=="number"?n.x:0,i=typeof n.tiltY=="number"?n.tiltY:typeof n.y=="number"?n.y:-1,o=typeof n.tiltZ=="number"?n.tiltZ:typeof n.z=="number"?n.z:0,r=s,c=-i,l=-o;ce[0]=r,ce[1]=c,ce[2]=l;const d=Math.hypot(r,c,l),u=d>.001?9.8*qt/d:9.8*qt;Zt[0]=r*u,Zt[1]=c*u,Zt[2]=l*u,bo(r,c,l),Ae=!0},{frequency:x}),!0}catch{}return!1}var Ke;try{const x=(Ke=window==null?void 0:window.creationSensors)==null?void 0:Ke.accelerometer;x&&(typeof x.isAvailable=="function"?x.isAvailable().then(s=>{s&&$t(60)}).catch(()=>{}):$t(60));let t=0;const e=40,n=setInterval(()=>{var s;if(Ae){clearInterval(n);return}try{const i=(s=window==null?void 0:window.creationSensors)==null?void 0:s.accelerometer;i&&(typeof i.isAvailable=="function"?i.isAvailable().then(o=>{o&&$t(60)}).catch(()=>{}):$t(60))}catch{}t++,t>=e&&clearInterval(n)},300)}catch{}function Eo(){if(Ae)return Zt;const x=Math.sin(_t),t=-Math.sin(Ct),e=-Math.cos(Ct)*Math.cos(_t),n=new Float32Array([x,e,t]),s=Math.hypot(n[0],n[1],n[2])||1;return n[0]/=s,n[1]/=s,n[2]/=s,n[0]*=9.8*qt,n[1]*=9.8*qt,n[2]*=9.8*qt,n}y.enable(y.DEPTH_TEST);y.clearColor(.02,.02,.035,1);y.enable(y.BLEND);y.blendFunc(y.SRC_ALPHA,y.ONE_MINUS_SRC_ALPHA);try{y.enable(y.CULL_FACE)}catch{}let Ze=performance.now();const Q=new Oi({gravity:new a(0,-9.8,0)});Q.broadphase=new zt(Q);Q.allowSleep=!0;Q.solver.iterations=20;Q.defaultContactMaterial.friction=.4;Q.defaultContactMaterial.restitution=.25;const hn=new St("ground"),Jt=new St("dice");Q.addContactMaterial(new Tt(hn,Jt,{friction:.45,restitution:.05}));Q.addContactMaterial(new Tt(Jt,Jt,{friction:.45,restitution:.05}));function Ft(x,t){const e=new Vt(new a(t[0],t[1],t[2])),n=new F({mass:0,material:hn});n.addShape(e),n.position.set(x[0],x[1],x[2]),Q.addBody(n)}const Bt=.02;Ft([$,0,0],[Bt,$,$]);Ft([-$,0,0],[Bt,$,$]);Ft([0,$,0],[$,Bt,$]);Ft([0,-$,0],[$,Bt,$]);Ft([0,0,$],[$,$,Bt]);Ft([0,0,-$],[$,$,Bt]);function Ao(x){const t=Eo(),e=Math.max(-30,Math.min(30,t[0])),n=Math.max(-30,Math.min(30,t[1])),s=Math.max(-30,Math.min(30,t[2])),i=Q.gravity,o=Math.hypot(i.x,i.y,i.z)||1,r=Math.hypot(e,n,s)||1,c=i.x/o,l=i.y/o,d=i.z/o,u=e/r,h=n/r,p=s/r,m=Math.max(-1,Math.min(1,c*u+l*h+d*p)),w=Math.acos(m);if(Q.gravity.set(e,n,s),w>.2)for(let g=0;g<Y.length;g++){const f=Y[g].body;try{f.wakeUp(),f.angularVelocity.set(f.angularVelocity.x*.5,f.angularVelocity.y*.5,f.angularVelocity.z*.5),f.torque.set(0,0,0)}catch{}}const v=1/60;Q.step(v,x,3)}function dn(x){Yi();const t=Math.min(.033,Math.max(.001,(x-Ze)*.001));Ze=x,$e||(Y.push(be([0,1.2,0],{initialVelocity:[0,0,0],angularVelocity:[0,0,0]})),$e=!0),Ao(t),y.clear(y.COLOR_BUFFER_BIT|y.DEPTH_BUFFER_BIT);const e=Z.width/Math.max(1,Z.height),n=wn(Math.PI/3,e,.05,100);let s=te();s=xn(s,[0,0,-5]);const i=ze(n,s),o=[Math.cos(Mt)*Math.cos(he),Math.sin(Mt),Math.cos(Mt)*Math.sin(he)],r=8,c=[-o[0]*r,-o[1]*r,-o[2]*r],u=Gi(c,[0,0,0],[0,1,0]),h=Ui(-3,3,-3,3,.5,15),p=ze(h,u);y.bindFramebuffer(y.FRAMEBUFFER,ln),y.viewport(0,0,Qt,Qt),y.clear(y.DEPTH_BUFFER_BIT),y.useProgram(ge),y.uniformMatrix4fv(wo,!1,p),y.bindVertexArray(le);let m=te();y.uniformMatrix4fv(Xe,!1,m),y.drawElements(y.TRIANGLES,30,y.UNSIGNED_SHORT,0),y.bindVertexArray(ae);for(let v=0;v<Y.length;v++){const g=Y[v].body,f=new Float32Array([g.quaternion.x,g.quaternion.y,g.quaternion.z,g.quaternion.w]),b=He(f).slice(0),E=Y[v].size*Yt;b[0]*=E,b[1]*=E,b[2]*=E,b[4]*=E,b[5]*=E,b[6]*=E,b[8]*=E,b[9]*=E,b[10]*=E,b[12]=g.position.x,b[13]=g.position.y,b[14]=g.position.z,y.uniformMatrix4fv(Xe,!1,b),y.drawElements(y.TRIANGLES,Ot.indices.length,y.UNSIGNED_INT,0)}y.bindFramebuffer(y.FRAMEBUFFER,null),y.viewport(0,0,Z.width,Z.height),y.useProgram(wt),y.uniformMatrix4fv(so,!1,i),y.uniformMatrix4fv(io,!1,p),y.uniform3f(ro,o[0],o[1],o[2]),y.activeTexture(y.TEXTURE0),y.bindTexture(y.TEXTURE_2D,xe),y.uniform1i(oo,0),y.bindVertexArray(ae);for(let v=0;v<Y.length;v++){const f=Y[v].body,A=new Float32Array([f.quaternion.x,f.quaternion.y,f.quaternion.z,f.quaternion.w]),E=He(A).slice(0),_=yt*Yt,M=yt*Yt,R=yt*Yt;E[0]*=_,E[1]*=_,E[2]*=_,E[4]*=M,E[5]*=M,E[6]*=M,E[8]*=R,E[9]*=R,E[10]*=R,E[12]=f.position.x,E[13]=f.position.y,E[14]=f.position.z,y.uniform3f(Ye,.92,.92,.92),y.uniformMatrix4fv(Ge,!1,E),y.drawElements(y.TRIANGLES,Ot.indices.length,y.UNSIGNED_INT,0)}y.bindVertexArray(le);let w=te();y.uniformMatrix4fv(Ge,!1,w),y.uniform3f(Ye,.15,.15,.15),y.drawElements(y.TRIANGLES,30,y.UNSIGNED_SHORT,0),requestAnimationFrame(dn)}requestAnimationFrame(dn);fe.on("sideButton",()=>{if(Y.length<8)Y.push(be([(Math.random()-.5)*1.2,1.2+Math.random()*.4,(Math.random()-.5)*1.2]));else{const x=Y.pop();try{Q.removeBody(x.body)}catch{}}});fe.on("scrollWheel",({direction:x})=>{if(x==="up")Y.push(be([(Math.random()-.5)*1.2,1.2+Math.random()*.4,(Math.random()-.5)*1.2]));else if(Y.length>0){const t=Y.pop();try{Q.removeBody(t.body)}catch{}}});try{typeof window<"u"&&(window.__diceDebug={getSpeeds:()=>Y.map(x=>{const t=x.body.velocity;return Math.hypot(t.x,t.y,t.z)}),getAngularSpeeds:()=>Y.map(x=>{const t=x.body.angularVelocity;return Math.hypot(t.x,t.y,t.z)}),getSleeping:()=>Y.map(x=>x.body.sleepState===2),getCount:()=>Y.length})}catch{}
